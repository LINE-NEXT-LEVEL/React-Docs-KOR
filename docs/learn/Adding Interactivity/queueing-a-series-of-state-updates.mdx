import { Code } from '../../../src/components/Code';
import { Card } from '../../../src/components/Card';

# 일련의 상태 업데이트 저장하기

상태 변수를 세팅하는 것은 또 다른 렌더링을 저장합니다. 하지만 가끔 여러분은 다음 렌더링을 저장하기전에 특정 값에 대해서 다수의 명령을 실행하고 싶을 수 있습니다.
이것을 하기위해서는, React가 상태 업데이트를 어떻게 일괄처리하는지에 대해 이해하는 것이 도움이 됩니다.

:::note You will learn

- "일괄 처리(batching)"가 의미하는 바와 React가 다수의 상태 업데이트를 처리하기 위해 일괄처리를 활용하는 방법
- 한 상태 변수에 순차적으로 업데이트들을 적용하는 방법

:::

## React는 상태 업데이트를 일괄처리(batch)합니다

여러분은 "+3" 버튼을 클릭하는 것이 `setNumber(number+1)`을 세번 호출하기 때문에 카운터를 3회 증가시킬 것이라 예상할 것 입니다.

<Code src="https://codesandbox.io/s/984x0t?file=%2FApp.js&utm_medium=sandpack" />

그러나 이전 섹션에서 떠올릴 수 있듯, [각 렌더링에서 상태값은 고정](https://beta.reactjs.org/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time)이기 때문에,
`setNumber(1)`을 얼마나 부르던지 간에 첫 렌더링 이벤트 핸들러 내부의 `number`는 항상 `0`입니다.

```js
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

하지만 논의할만한 또 다른 요소가 있습니다. **React는 여러분의 상태 업데이트를 실행하기 전에 이벤트 핸들러 내부의 *모든*코드가 실행될 때까지 기다립니다.**
이것은 모든 `setNumber()`가 호출된*후에* 리렌더링이 발생하는 이유입니다.

이는 여러분이 식당에서 종업원이 주문을 받는것을 떠올리게 할 것입니다. 종업원은 여러분이 첫 요리를 언급할때 부엌으로 뛰어가지 않습니다!
대신에, 여러분이 주문을 마무리하도록 하고, 변경하도록 하며, 그리고 테이블의 다른 사람에게 주문을 받기까지 합니다.

![image](https://user-images.githubusercontent.com/15559593/205052110-f0ec310c-5975-4e8b-9a74-85811144126a.png)

이 것은 여러분이 많은 [리렌더링](https://beta.reactjs.org/learn/render-and-commit#re-renders-when-state-updates)없이도 다수의 state 변수들을 업데이트하도록 합니다. (여러 컴포넌트로부터도 마찬가지입니다)
하지만 이는 여러분의 이벤트 핸들러와 그 내부의 코드들이 완료된 *후*가 아니면 UI가 업데이트 되지 않는다는 의미입니다.
이 행동은 **'일괄처리(batching)'**로 알려져 있으며, 여러분의 React 앱이 훨씬 빠르게 동작하도록 합니다.
또한, 혼란스러울 수 있는 일부 상태만 업데이트 되어 "반정도 처리된" 렌더링이 발생하지 않도록합니다.

**React는 클릭들과 같은 _다수의_ 의도된 이벤트들을 일괄처리하지 않습니다.** 각 클릭은 별개로 처리됩니다. React는 대개 안전한 경우에만 일괄처리를 수행합니다.
예를들어 첫 버튼 클릭이 폼을 비활성화한다면, 두번째 클릭이 다시 제출하지 않게하는 것을 보증해줍니다.

## 다음 렌더링 전에 한 상태 변수를 여러번 업데이트 하는 것

이는 흔한 케이스는 아니지만, 여러분이 다음 렌더링 전에 `setNumber(number + 1)` 처럼 *다음 상태 값*을 넘기는 대신 한 state 변수의 값을 여러번 업데이트 하고싶다면, 여러분은 `setNumber(n => n + 1)`처럼 저장된 이전 값으로 다음 state를 계산하는 함수를 넘겨 줄 수 있습니다.
이는 React에게 상태값을 대체하는 대신, "상태 값으로 무언가를 해"라고 전달하는 방법입니다.

카운터를 증가시키는 것을 시도해보세요:

<Code src="https://codesandbox.io/s/mg96dj?file=%2FApp.js&from-sandpack=true" />

여기서, 여러분이 상태 설정자에 전달하게되는 `n => n + 1`는 **업데이터 함수**라고 불립니다.

1. React는 이벤트 핸들러 내부의 다른 코드들이 모두 실행된 다음에 이 함수가 실행되도록 저장합니다.
2. 다음 렌더링동안, React는 대기열을 실행하고 마지막 업데이트 값을 여러분에게 줍니다.

```js
setNumber((n) => n + 1);
setNumber((n) => n + 1);
setNumber((n) => n + 1);
```

어떻게 React가 이벤트 핸들러를 실행하는 동안 여러줄의 코드를 동작시키는지 살펴봅시다.

1. `setNumber(n => n + 1)`: `n => n + 1`는 함수입니다. React는 이를 대기열에 넣습니다.
2. `setNumber(n => n + 1)`: `n => n + 1`는 함수입니다. React는 이를 대기열에 넣습니다.
3. `setNumber(n => n + 1)`: `n => n + 1`는 함수입니다. React는 이를 대기열에 넣습니다.

여러분이 다음 렌더링동안 `useState`를 호출하면, React는 대기열을 실행합니다. 이전 `number`값은 `0`이었습니다.
따라서 0이 React가 업데이터함수의 첫 `n`값으로 넘겨준 값입니다. React는 이전 업데이터 함수의 반환값을 가지고
다음 업데이터함수의 'n'으로 넘겨줍니다. 계속해서요.

| **저장된 업데이트** | `n` | **반환값**  |
| ------------------- | --- | ----------- |
| `n => n + 1`        | `0` | `0 + 1 = 1` |
| `n => n + 1`        | `1` | `1 + 1 = 2` |
| `n => n + 1`        | `2` | `2 + 1 = 3` |

React는 `3`을 최종 결과값으로 갖고 `useState`에서 반환합니다.

이것은 위의 예제에서 "+3"을 클릭했을때 값이 3증가하는 이유입니다.

## 상태를 교체한 후에 업데이트하면 생기는 일

이 이벤트 핸들러는 어떨까요? 다음 렌더링에서 `number`가 어떤 값을 가질지 생각해봅시다.

```js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
}}>
```

<Code src="https://codesandbox.io/s/389fty?file=%2FApp.js&utm_medium=sandpack" />

이 이벤트 핸들러는 React에게 다음과 같이 명령합니다:

1.`setNumber(number + 5)`:`number`는 `0`입니다, 따라서 `setNumberk(0 + 5)`가 됩니다. React는 **"_5로 교체_"를 대기열에 추가합니다** 2.`setNumber(n => n + 1)`:`n => n + 1`은 업데이터 함수입니다. React는 대기열에 그 *함수*를 추가합니다.

다음 렌더링 동안 상태 대기열을 실행합니다.

| **저장된 업데이트** | `n`         | **반환값**  |
| ------------------- | ----------- | ----------- |
| "`5`로 교체"        | `0`(미사용) | `5`         |
| `n => n + 1`        | `5`         | `5 + 1 = 6` |

React는 `6`을 최종 결과값으로 useState에서 반환합니다

<Card description="여러분은 `setState(x)`가 사실상 `setState(n => x)`와 같이 동작하고, `n`이 미사용 된다는 것을 알았을 것입니다." />

## 업데이트 후에 상태를 교체하면 발생하는 일

예시를 하나 더 시도해 보겠습니다. `number`가 다음 렌더링에서 어떤 값을 가질까요?

```js
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
  setNumber(42);
}}>
```

<Code src="https://codesandbox.io/s/478r4f?file=/App.js&utm_medium=sandpack" />

React가 이 이벤트 핸들러를 여러줄의 코드를 어떻게 실행하는지 살펴보겠습니다.

1. `setNumber(number + 5)`:`number`는 `0`이므로, `setNumber(0 + 5)`입니다.
   \*\*React는 "_5로 교체_"를 대기열에 추가합니다.
2. `setNumber(n => n + 1)`: `n => n + 1`은 업데이터 함수입니다. React는 그 *함수*를 대기열에 추가합니다.
3. `setNumber(42)`: React는 "_42로 교체_"를 대기열에 추가합니다

다음 렌더링 동안 React는 다음 대기열을 수행합니다.

| **저장된 업데이트** | `n`         | **반환값**  |
| ------------------- | ----------- | ----------- |
| "`5`로 교체"        | `0`(미사용) | `5`         |
| `n => n + 1`        | `5`         | `5 + 1 = 6` |
| `42로 교체`         | `6`(미사용) | `42`        |

따라서 React는 `42`를 최종 결과값으로 `useState`에서 반환합니다.

요약하자면 다음은 `setNumber` 상태 설정자에 무엇을 넘기는 생각하는 방법입니다.

- 업데이터 함수(`n => n + 1`과 같은)가 대기열에 추가됩니다.
- 다른 값(`5`와 같은)은 "`5`로 교체"를 대기열에 추가하고, 대기열에 이미 추가된 것들을 무시합니다.

이벤트 핸들러가 완료된 후에, React는 리렌더링을 트리거하고, 리렌더링 되는 동안 React는 대기열에 있는 작업들을 수행합니다.
업데이터 함수는 렌더링 되는 동안 수행되므로, 상태 변경(set) 함수는 [순수](https://beta.reactjs.org/learn/keeping-components-pure)해야하고
오직 결과만을 *반환*합니다. 그 내부에서 상태를 설정하는 것은 사이드 이펙트를 발생시킬 수 있으므로 시도하지마세요.
Strict Mode에서, React는 여러분이 실수를 찾는 것을 돕기위해 각 업데이터 함수를 두번 씩(두번 째 결과는 버립니다) 수행합니다.

## 네이밍 컨벤션

일반적으로 상태 변수의 첫 글자들을 업데이터 함수의 인자의 이름을 짓는데 사용합니다.

```js
setEnabled((e) => !e);
setLastName((ln) => ln.reverse());
setFriendCount((fc) => fc * 2);
```

여러분이 장황한 코드를 선호한다면, 다른 흔한 컨벤션은 상태 변수 이름 전체를 반복하는 것입니다.
`setEnabled(enabled => !enabled)`나 접두사를 붙여 `setEnabled(prevEnabled => !prevEnabled)`로 씁니다.

## 요약

- 상태를 설정하여도 현 렌더링에서는 값을 바꾸지 않고 다음 렌더링에 요청합니다.
- React는 이벤트 핸들러의 실행이 끝난 뒤 상태 업데이트를 수행합니다. 이를 일괄처리(batching)라 합니다.
- 어떤 이벤트를 여러번 업데이트 하고 싶다면, 여러분은 `setNumber(n => n + 1)` 업데이터 함수를 활용할 수 있습니다.

:::note 문제에 도전해보세요.

### 도전 1 : 요청 카운터 고치기

여러분이 사용자가 동시에 아트에 대해 여러 주문을 요청할 수 있는 아트 마켓 앱을 제작중입니다.
매 번 유저가 "Buy"버튼을 누를 때마다, "대기" 카운터가 1씩 증가해야 합니다.
3초가 지난뒤 "대기" 카운터는 감소해야하고, "완료" 카운터가 증가해야합니다.

그러나, "대기" 카운터는 의도한대로 동작하지 않았습니다. 여러분이 "Buy"를 누르면 `-1`로 감소했습니다.(불가능한 일입니다!)
그리고 빠르게 두번 클릭할 시, 두 카운터 모두 예상대로 동작하지 않았습니다.

왜 이렇게 되었을까요? 두 카운터들을 고쳐보세요.

<Code src="https://codesandbox.io/s/fh0rkn?file=%2FApp.js&utm_medium=sandpack" />

### 정답

`handleClick` 이벤트 핸들러의 내부에서, `대기`와 `완료`의 값들은 클릭이벤트 발생시의 값과 일치합니다.
첫 렌더링에서 `대기`는 `0`이었기 때문에, `setPending(pending -1)`은 잘못된 `setPending(-1)`이 되었습니다.
여러분이 카운터를 *증가*나 *감소*시키고 싶다면, 클릭동안 결정된 구체적인 값으로 설정하는 것이 낫고, 대신 업데이터 함수들을 전달할 수 있습니다.

<Code src="https://codesandbox.io/s/fiy7s9?file=/App.js&utm_medium=sandpack" />

이는 여러분이 카운터를 증가 혹은 감소 시킬때 클릭시의 상태 대신에 _가장 최근_ 상태로 연관지어 실행할 수 있도록
보장해줍니다.

### 도전 2 : 상태 대기열 직접 구현하기

이 도전에서는, 여러분은 React의 작은 부분을 처음부터 다시 구현하게 될 것입니다.
들리는 것만큼 어렵지는 않을 것 입니다.

sandbox 미리보기까지 스크롤해보세요. *네가지 테스트 케이스*를 발견할 수 있습니다.
케이스들은 여러분이 이 페이지에서 이전에 봤던 예시들과 일치합니다.
여러분의 임무는 각 케이스들의 알맞은 결과를 반환하는 `getFinalState' 함수를 구현하는 것 입니다.
만약 여러분이 잘 구현한다면, 네가지 테스트 모두 통과할 것 입니다.

여러분은 두가지 인자를 받습니다: `baseState`는 초기상태(`0`과 같은)이고, `queue`는 숫자들(`5`와 같은)의 조합과
업데이트 함수들(`n=>n+1`과 같은)을 추가된 순서로 갖고있는 배열입니다.

여러분의 임무는 이 페이지의 테이블들이 보여주는 것처럼 최종 상태를 반환하는 것입니다.

<Code src="https://codesandbox.io/s/xkix2y?file=%2FprocessQueue.js&utm_medium=sandpack" />

### 힌트

만약 여러분이 막히는 것 같다면, 이 코드 구조로 시작해보세요.

```js
export function getFinalState(baseState, queue) {
  let finalState = baseState;

  for (let update of queue) {
    if (typeof update === 'function') {
      // TODO: apply the updater function
    } else {
      // TODO: replace the state
    }
  }

  return finalState;
}
```

누락된 줄들을 채워보세요!

### 정답

이는 이 페이지에서 소개되었던, React가 최종 상태를 계산하기 위해 사용하는 정확한 알고리즘입니다.

<Code src="https://codesandbox.io/s/ghipi9?file=%2FprocessQueue.js&utm_medium=sandpack" />
이제 여러분은 이 파트의 React가 어떻게 동작하는지 알게되었습니다.

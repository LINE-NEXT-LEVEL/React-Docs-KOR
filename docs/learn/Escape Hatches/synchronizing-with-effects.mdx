# effect 를 동기화하기

몇 컴포넌트들은 외부 시스템과 동기화할 필요가 있습니다. 예를 들어, React 상태에 기반한 React가 아닌 컴포넌트를 제어하거나, 서버 연결을 설정하거나, 화면에 컴포넌트나 나타날 때 분석 로그를 보내고 싶을 수 있습니다.
Effects는 렌더링 후에 코드를 실행해서 React 밖의 시스템과 컴포넌트를 동기화할 수 있습니다.

:::info 여러분이 배울 것
- Effects가 무엇인지
- Effects가 이벤트와 어떻게 다른지
- 컴포넌트 내부에 Effect를 선언하는 방법
- 불필요하게 Effects를 리렌더링하는 것을 건너뛰는 방법
- 개발에서 Effects가 두 번 실행되는 이유와 그것을 고치는 방법 
:::

## Effects는 무엇이고 이벤트와 어떻게 다를까요?

Effects로 들어가기 전에, React 컴포넌트 안의 두 가지 로직와 친숙해야 할 필요가 있습니다:

- **코드 렌더링**([UI 묘사하기](https://beta.reactjs.org/learn/describing-the-ui)에서 소개된)은 컴포넌트의 상위 레벨에 위치합니다.
prop과 상태를 받고 변형시킨 다음에 화면에서 볼 수 있도록 JSX를 반환하는 곳입니다.
[코드를 렌더링하는 것은 반드시 순수해야 합니다.](https://beta.reactjs.org/learn/keeping-components-pure)
수학 공식 처럼, 결과만을 계산하고 다른 어떤 것도 해서는 안됩니다.

- **이벤트 핸들러**([인터랙티비티 추가하기](https://beta.reactjs.org/learn/adding-interactivity)에서 소개된)는
컴포넌트 내에서 그냥 계산하는 것 이외의 것들을 하는 중첩된 함수입니다. 
이벤트 핸들러는 입력 필드를 업데이터하고, 제품을 사서 HTTP POST 요청을 보내거나 다른 화면로 사용자를 이끌 수 있습니다. 
이벤트 핸들러는 (프로그램의 상태에 따라 바뀌는)"[부작용](https://en.wikipedia.org/wiki/Side_effect_(computer_science))"
이 있고 특정한 사용자의 행동으로 일어납니다(예를 들어, 버튼을 클릭하거나 타이핑하는 것).

때떄로 이것만으로는 충분하지 않습니다. 스크린에 보일 떄마다 채팅 서버에 연결하는 `ChatRoom` 컴포넌트를 고려해보세요. 
서버에 연결하는 것은 순수한 계산이 아니기 떄문에 (부작용) 렌더링 동안에는 일어날 수 없습니다. 
그러나, 클릭 한 번으로 인해 채팅룸이 표시되는 특정 이벤트는 없습니다.

**Effect를 사용하면 특정 이벤트를 사용하는 것 이외에 렌더링으로 일어나는 부작용을 명시할 수 있습니다.**
채팅룸 안에서 메세지를 보내는 것은 특정 버튼을 클릭해서 사용자가 일으키기 떄문에 _이벤트_입니다.
그러나, 서버 연결을 설정하는 것은 컴포넌트가 보이도록 하는 인터랙션과 무관하게 일어날 필요가 있기 때문에 _Effect_입니다.
Effect는 화면 업데이트 후에 [렌더링 과정](rendering process)의 끝에 일어납니다.
React 컴포넌트와 다른 외부 시스템(네트워크나 다른 라이브러리)을 동기화하기에 적기입니다.

:::note note
이 텍스트에서 대문자 "Effect"는 위에서 설명한 React에 한정된 정의를 의미합니다. 예시: 렌더링에서 발생한 부작용(side effect).
더 넓은 프로그래밍 개념을 가리키기 위해서는 "부작용"이라고 부를 것입니다.
:::

## Effect가 필요 없을 수도 있습니다.

**컴포넌트에 급하게 Effect를 추가하지 마세요.** Effect는 보통 React 코드의 "단계에서 벗어나고" 외부 시스템과 동기화하기 위해 사용된다는 것을 유념하세요.
이는 브라우저 API, 위젯, 네트워크 등등을 포함합니다. Effect가 다른 상테에 의존하는 어떤 상태를 조정한다면, [Effect가 필요 없을 수 있습니다.](https://beta.reactjs.org/learn/you-might-not-need-an-effect)

## Effect를 작성하는 방법

Effect를 작성하기 위해서는 다음 세 단계를 따르세요:

1. **Effect를 선언하세요.** 기본적으로 Effect는 렌더링 다음에 일어납니다.
2. **Effect 의존도를 명시하세요.** 대부분의 Effect는 모든 렌더링 후에 일어나기 보다 _필요한_ 시점 이후에 다시 싱행되어야 합니다.
예를 들어, fade-in 애니메이션은 컴포넌트가 나타날 때에만 작동해야 합니다. 
채팅방을 연결하고 끊는 것은 컴포넌트가 나타나고 사라질 때만 일어나거나, 채링방이 변할 때만 일어나야 하니다. 
이것을 의존성을 명시해서 조절하는 방법을 배울 것입니다.

2. **필요하면 치우는 과정을 추가하세요.** 어떤 이펙트들은 작동할 때마다 멈추고, 되돌리고, 지우는 방법을 명시할 필요가 있습니다/
예를 들어, "연결"은 "연결해제"가 필요하고, "구독"은 "구독 해지"가 필요하고, "새로 고침"은 "취소나 "무시"가 필요합니다. _지움_함수를 반환해서 이러한 작업을 하는 방법을 배울 것입니다.

## 1단계: Effect를 선언하세요.

컴포넌트 안에 Effect를 선언하기 위해서는 React에서 `[useEffect 훅](https://beta.reactjs.org/reference/react/useEffect)`을 임포트해야 합니다.

```js
 import { useEffect } from 'react';
```

그리고 나서, 컴포넌트의 최상단에서 호출하고 Effect 안에 코드를 작성하세요:

```js 
function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
  });
  return <div />;
}
```

컴포넌트가 렌더링할 때마다, 리액트는 스크린을 업데이트하고 *그리고 나서* `useEffect` 안의 코드를 실행합니다.
다른 말로, `useEffect`는 **그 렌더링이 스크린에 반영될 떄까지 코드의 일부가 동작하는 것을 "연기"시킵니다.**

외부 시스템과 동기화하기 위해 Effect를 사용하는 방법을 알아봅니삳. 
`<VideoPlayer/>` 컴포넌트를 고려해보세요. 이 컴포넌트에 `isPlaying` prop을 전달해 비디오를 실행하고 멈추는 것을 조절할 수 있다면 멋질 것입니다. 

```js
<VideoPlayer isPlaying={isPlaying} />;
```

여러분이 직접 만든 `VideoPlayer` 컴포넌트는 브라우저에 내장되어있는 `[<video>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video)` 태그를 렌더링합니다.

```js
function VideoPlayer({ src, isPlaying }) {
  // TODO: do something with isPlaying
  return <video src={src} />;
}
```

그러나, 브라우저의 `<video>`태그는 `isPlaying` prop을 갖고 있지 않습니다.
비디오를 조정하는 방법은 DOM 앨리먼트의 `play()`와 `pause()`을 수동으로 부르는 것 뿐입니다.
**`isPlaying`prop의 값과 동기화를 시켜야 하고, isPlaying 은 `play()` 와 `pause()`를 내부적으로 사용해 
현재 비디오를 실행_해야한다_는 것을 말해주어야합니다.**

먼저 `video` DOM 노드로부터 [ref를 얻어야](https://beta.reactjs.org/learn/manipulating-the-dom-with-refs)
합니다.

렌더링하면서 `play()`나 `pause()`를 부르고 싶은 마음이 들 수도 있지만, 그 방법은 옳지 않습니다:

<Code src="https://codesandbox.io/s/fjm8gc?file=/App.js&utm_medium=sandpack"/>

이 코드가 틀린 이유는 렌더링하면서 DOM으로 무언가를 하려고 시도했기 때문입니다.
리액트에서는 [렌더링은 JSX의 순수계산이어야만 하고](https://beta.reactjs.org/learn/keeping-components-pure)
DOM을 변경하거나 하는 부작용을 포함해서는 안됩니다.

더욱이, `VideoPlayer`가 처음으로 불릴 떄, DOM은 아직 존재하지 않습니다!
React는 JSX가 반환될 때까지 어떤 DOM이 생성될지 모르기 떄문에 `play()`나 `pause()`를 부를 DOM 노드가 아직 없습니다.

여기 해결책은 **렌더링 계산 밖으로 코드를 가져와서 `useEffect`를 사용한 부작용으로 감싸주는 것입니다.**

```js
import { useEffect, useRef } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

Effect에 DOM 업데이트를 감싸주면서, React가 화면을 먼저 업데이트하도록 해줄 수 있습니다.
그리고 나서 Effect가 돌아가죠.

`VideoPlayer`컴포넌트가 렌더링될 때 (처음이거나 다시 렌더링되는 경우 중 하나).
몇 가지 일들이 일어날 수 있습니다. 
먼저, React는 DOM안의 `<video>` 태그가 옳은 prop을 갖고 있는지 확인하면서 화면을 업데이트할 것입니다.
그리고 나서야 React는 Effect를 실행할 것입니다.
마지막으로, Effect가 `isPlaying` prop의 값에 따라 `play()`나 `pause()`를 부를 것입니다.

실행/멈춤을 여러번 눌러보고 비디오 플레이어가 어떻게 `isPlaying`값과 동기화되어서 작동하는지 확인해보세요.

<Code src="https://codesandbox.io/s/dvynjy?file=%2FApp.js&utm_medium=sandpack"/>

이 예시에서, React 상태와 동기화한 "외부 시스템"은 브라우저의 미디어 API였습니다. 
여러분은 과거의 React가 아닌 코드(jQuery 플러그인과 같은)를 선언적인 React 컴포넌트로 감싸줄 때도 비슷한 접근을 사용할 수 있습니다.

비디오 플레이어를 조정하는 것은 실제로 훨씬 더 복잡하다는 것을 알아두세요. `play()` 호출이 실패할 수도 있고, 사용자가 브라우저의 내장된 컨트롤 기능을 사용해서 실행하거나 멈출 수도 있습니다.
이 예시는 매우 간소화된 것입니다.

:::danger 주의할 점

기본적으로 Effeect는 매 렌더링 후에 돌아갑니다. 다음과 같은 코드가 왜 **무한루프를 생성하는 지**에 대한 이유입니다:

```js 
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```

Effect는 렌더링의 _결과_를 실행합니다. 상태를 설정하는 것은 렌더링을 _유발_합니다.
Effect에서 직접적으로 상태를 설정하는 것은 동력 콘센트의 전원을 스스로에게 꽂는 것과 같습니다.
Effect가 동작하고, 상태를 설정하고, 리렌더링을 일으키고, Effect가 동작하고, 다시 상태를 설정하고 이와 같은 일이 반복해서 일어납니다.

Effect는 컴포넌트를 _외부_ 시스템과 동기화해야합니다. 만약 외부 시스템이 없고 다른 상테에 기반한 몇 가지 상태를 변경하고 싶을 뿐이라면, [Effect가 필요 없을 수도 있습니다.](https://beta.reactjs.org/learn/you-might-not-need-an-effect)

:::

## 2단계: Effect의 의존성을 명확히 하기

기본적으로, Effect는 _모든_ 렌더링 후에 돌아갑니다. 종종 이는 **원하는 바가 아닐 수** 있습니다:

- 가끔 이 동작은 느립니다. 외부 시스템과 동기화하는 것은 항상 즉각적이지 않기 떄문에 불필요하다면 넘어가고 싶을 수 있습니다.
예를 들어, 모든 키입력마다 채팅 서버를 재연결 하고 싶지는 않을 것입니다.
- 가끔 이 동작은 잘못되었습니다. 예를 들어, 모든 키입력마다 컴포넌트에 fade-in 애니메이션을 넣고 싶지 않을 수 있습니다. 
이 에니메이션은 컴포넌트가 처음 나타날 때에만 동작해야 합니다.

이 문제를 증명하기 위해, 몇몇 개의 `console.log` 호출과 부모 컴포넌트의 상태를 업데이트 하는 텍스트 입력이 있는 이전에 사용한 예시가 있습니다.
타이핑이 어떻게 Effect를 계속 돌아가게 하는지 확인해보세요:

<Code src="https://codesandbox.io/s/z1hxjk?file=%2FApp.js&utm_medium=sandpack"/>

`useEffect` 호출을 할 때 두 번쨰 인자로 의존성 배열을 명시해서 불필요하게 Effect를 다시 돌아가게 하는 것을 피하도록 할 수 있습니다.
위 예시의 14번쨰 줄에 빈 `[]` 배열을 추가하는 것으로 시작해보세요:

```js 
 useEffect(() => {
    // ...
  }, []);
```

`React 훅인 useEffect가 `isPlaying` 의존성을 갖고 있지 않다는` 에러를 봐야합니다:

<Code src="https://codesandbox.io/s/dszumx?file=%2FApp.js&utm_medium=sandpack"/>

이 문제는 Effect 내부의 코드가 무엇을 할지 결정하기 위해 `isPlaying` prop에 _의존_하는 것입니다.
하지만 이 의존성은 명백하게 선언되지 않았습니다. 이 문제를 고치기 위해서는 의존성 배열에 `isPlaying`을 추가해보세요:

```js 
 useEffect(() => {
    if (isPlaying) { // It's used here...
      // ...
    } else {
      // ...
    }
  }, [isPlaying]); // ...so it must be declared here!
```

이제 모든 의존성이 선업되었기 떄문에 에러가 없습니다. `[isPlaying]`을 의존성 배열로 명시하는 것은
만약 `isPlaying`이 이전 렌더링의 했을 떄와 같으면 Effect를 재실행하지 말라고 React에게 말해주는 것입니다.
이 변화로 입력창에 입력하는 것은 Effect가 다시 실행되는 것을 막아주지만 실행/멈춤을 누르면 여전히 Effecet가 동작합니다.

<Code src="https://codesandbox.io/s/6o7zyc?file=%2FApp.js&utm_medium=sandpack"/>

의존성 배열은 여러 개의 의존성을 갖고 있을 수 있습니다.
React는 이전 렌더링동안 갖고 있던 값과 비교해서 명시한 _모든_ 의존성이 같으면 리렌더링을 하지 않습니다.
React는 `[Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)` 비교를 사용해서 의존 값들을 비교합니다.
더 자세한 내용은 [`useEffect` API](https://beta.reactjs.org/reference/react/useEffect#reference)를 확인해보세요.

**의존성을 "선택"할 수 없다는 것을 알아두세요.** 만약 명시해놓은 의존성들과 Effect 내부의 코드에 기반했을 떄 React가 생각하는 의존성이 일치하지 않는다면 lint error를 얻게 될 것입니다.
이는 코드의 버그를 잡는 데 도움이 됩니다. Effect가 몇 개의 값들을 사용하지만 그 값들이 변할 떄 Effect가 돌아가길 원하지 않는다면, [Effect코드가 그 의존성을 "필요"로 하지 않도록 직접 코드를 수정](https://beta.reactjs.org/learn/lifecycle-of-reactive-effects#what-to-do-when-you-dont-want-to-re-synchronize)해야 할 것입니다.

:::danger 주의할 점

의존성이 _없는_배열과 빈 `[]` 배열은 매우 다릅니다:

```js 
useEffect(() => {
  // 모든 렌더링마다 동작합니다.
});

useEffect(() => {
  // 마운트 될 때만 동작합니다. (컴포넌트가 나타날 떄)
}, []);

useEffect(() => {
  // 마운트 될 떄 *그리고 또* 지난 렌더링 이후로 a 또는 b가 변했을 때 동작합니다.
}, [a, b]);
```

다음 단계에서 "마운트"가 무엇을 의미하는지 더 자세히 알아 볼 것입니다. 

:::

:::note DEEP DIVE

### 왜 ref는 의존성 배열에서 빠지나요?

Effect는 `ref`와 `isPlaying` 둘 다 사용하고 있지만 `isPlaying`만 의존성 배열에 선언되어있습니다:

```js

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);

```

이는 `ref`객체는 _안정적인 동일성_을 갖고 있기 때문입니다:
React는 모든 렌더링에서 `useRef`를 호출할 때 [항상 같은 객체를 얻을 것](https://beta.reactjs.org/reference/react/useRef#returns)을 보장합니다.
그 객체는 절대 변하지 않기 때문에 Effect를 다시 실행하게 하지도 않을 것입니다.
따라서 ref 를 포함하는지 아닌지를 중요하지 않습니다. 포함해도 괜찮습니다:

```js

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying, ref]);

```

`useState`로 반환된 [`set`함수](https://beta.reactjs.org/reference/react/useState#setstate)도 안정적인 동일성을 갖고 있기 떄문에 의존성에서 제외된 것을 종종 보게 될 것입니다.
만약 linter가 에러 없이 의존성에서 제외한다면 안전한 것입니다.

항상 안정적인 의존성을 제외하는 것은 linter 가 그 객체가 안정적이라는 것을 "볼" 수 있을 때만 가능합니다.
예를 들어, 만약 `ref`가 부모 컴포넌트로부터 전달된다면 의존성 배열에 명시해야 합니다. 
왜냐하면 부모의 컴포넌트가 항상 같은 ref를 넘겨주는지, 아니면 여러개의 ref중의 하나를 조건부로 넘겨주는지 모를 수 있기 떄문에 명시하는 것이 좋습니다.
그래야만 Effect가 어떤 ref 가 전달되는 지 여부에 의존할 수 있습니다.

:::

## 3단계: 필요하다면 cleanup을 추가하세요

다른 예시를 고려해보세요.
# effect 를 동기화하기

몇 컴포넌트들은 외부 시스템과 동기화할 필요가 있습니다. 예를 들어, React 상태에 기반한 React가 아닌 컴포넌트를 제어하거나, 서버 연결을 설정하거나, 화면에 컴포넌트나 나타날 때 분석 로그를 보내고 싶을 수 있습니다.
Effects는 렌더링 후에 코드를 실행해서 React 밖의 시스템과 컴포넌트를 동기화할 수 있습니다.

:::info 여러분이 배울 것
- Effects가 무엇인지
- Effects가 이벤트와 어떻게 다른지
- 컴포넌트 내부에 Effect를 선언하는 방법
- 불필요하게 Effects를 리렌더링하는 것을 건너뛰는 방법
- 개발에서 Effects가 두 번 실행되는 이유와 그것을 고치는 방법 
:::

## Effects는 무엇이고 이벤트와 어떻게 다를까요?

Effects로 들어가기 전에, React 컴포넌트 안의 두 가지 로직와 친숙해야 할 필요가 있습니다:

- **코드 렌더링**([UI 묘사하기](https://beta.reactjs.org/learn/describing-the-ui)에서 소개된)은 컴포넌트의 상위 레벨에 위치합니다.
prop과 상태를 받고 변형시킨 다음에 화면에서 볼 수 있도록 JSX를 반환하는 곳입니다.
[코드를 렌더링하는 것은 반드시 순수해야 합니다.](https://beta.reactjs.org/learn/keeping-components-pure)
수학 공식 처럼, 결과만을 계산하고 다른 어떤 것도 해서는 안됩니다.

- **이벤트 핸들러**([인터랙티비티 추가하기](https://beta.reactjs.org/learn/adding-interactivity)에서 소개된)는
컴포넌트 내에서 그냥 계산하는 것 이외의 것들을 하는 중첩된 함수입니다. 
이벤트 핸들러는 입력 필드를 업데이터하고, 제품을 사서 HTTP POST 요청을 보내거나 다른 화면로 사용자를 이끌 수 있습니다. 
이벤트 핸들러는 (프로그램의 상태에 따라 바뀌는)"[부작용](https://en.wikipedia.org/wiki/Side_effect_(computer_science))"
이 있고 특정한 사용자의 행동으로 일어납니다(예를 들어, 버튼을 클릭하거나 타이핑하는 것).

때떄로 이것만으로는 충분하지 않습니다. 스크린에 보일 떄마다 채팅 서버에 연결하는 `ChatRoom` 컴포넌트를 고려해보세요. 
서버에 연결하는 것은 순수한 계산이 아니기 떄문에 (부작용) 렌더링 동안에는 일어날 수 없습니다. 
그러나, 클릭 한 번으로 인해 채팅룸이 표시되는 특정 이벤트는 없습니다.

**Effect를 사용하면 특정 이벤트를 사용하는 것 이외에 렌더링으로 일어나는 부작용을 명시할 수 있습니다.**
채팅룸 안에서 메세지를 보내는 것은 특정 버튼을 클릭해서 사용자가 일으키기 떄문에 _이벤트_입니다.
그러나, 서버 연결을 설정하는 것은 컴포넌트가 보이도록 하는 인터랙션과 무관하게 일어날 필요가 있기 때문에 _Effect_입니다.
Effect는 화면 업데이트 후에 [렌더링 과정](rendering process)의 끝에 일어납니다.
React 컴포넌트와 다른 외부 시스템(네트워크나 다른 라이브러리)을 동기화하기에 적기입니다.

:::note note
이 텍스트에서 대문자 "Effect"는 위에서 설명한 React에 한정된 정의를 의미합니다. 예시: 렌더링에서 발생한 부작용(side effect).
더 넓은 프로그래밍 개념을 가리키기 위해서는 "부작용"이라고 부를 것입니다.
:::

## Effect가 필요 없을 수도 있습니다.

**컴포넌트에 급하게 Effect를 추가하지 마세요.** Effect는 보통 React 코드의 "단계에서 벗어나고" 외부 시스템과 동기화하기 위해 사용된다는 것을 유념하세요.
이는 브라우저 API, 위젯, 네트워크 등등을 포함합니다. Effect가 다른 상테에 의존하는 어떤 상태를 조정한다면, [Effect가 필요 없을 수 있습니다.](https://beta.reactjs.org/learn/you-might-not-need-an-effect)

## Effect를 작성하는 방법

Effect를 작성하기 위해서는 다음 세 단계를 따르세요:

1. **Effect를 선언하세요.** 기본적으로 Effect는 렌더링 다음에 일어납니다.
2. **Effect 의존도를 명시하세요.** 대부분의 Effect는 모든 렌더링 후에 일어나기 보다 _필요한_ 시점 이후에 다시 싱행되어야 합니다.
예를 들어, fade-in 애니메이션은 컴포넌트가 나타날 때에만 작동해야 합니다. 
채팅방을 연결하고 끊는 것은 컴포넌트가 나타나고 사라질 때만 일어나거나, 채링방이 변할 때만 일어나야 하니다. 
이것을 의존성을 명시해서 조절하는 방법을 배울 것입니다.

2. **필요하면 치우는 과정을 추가하세요.** 어떤 이펙트들은 작동할 때마다 멈추고, 되돌리고, 지우는 방법을 명시할 필요가 있습니다/
예를 들어, "연결"은 "연결해제"가 필요하고, "구독"은 "구독 해지"가 필요하고, "새로 고침"은 "취소나 "무시"가 필요합니다. _지움_함수를 반환해서 이러한 작업을 하는 방법을 배울 것입니다.

## 1단계: Effect를 선언하세요.

컴포넌트 안에 Effect를 선언하기 위해서는 React에서 `[useEffect 훅](https://beta.reactjs.org/reference/react/useEffect)`을 임포트해야 합니다.

```js
 import { useEffect } from 'react';
```

그리고 나서, 컴포넌트의 최상단에서 호출하고 Effect 안에 코드를 작성하세요:

```js 
function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
  });
  return <div />;
}
```

컴포넌트가 렌더링할 때마다, 리액트는 스크린을 업데이트하고 *그리고 나서* `useEffect` 안의 코드를 실행합니다.
다른 말로, `useEffect`는 **그 렌더링이 스크린에 반영될 떄까지 코드의 일부가 동작하는 것을 "연기"시킵니다.**

외부 시스템과 동기화하기 위해 Effect를 사용하는 방법을 알아봅니삳. 
`<VideoPlayer/>` 컴포넌트를 고려해보세요. 이 컴포넌트에 `isPlaying` prop을 전달해 비디오를 실행하고 멈추는 것을 조절할 수 있다면 멋질 것입니다. 

```js
<VideoPlayer isPlaying={isPlaying} />;
```

여러분이 직접 만든 `VideoPlayer` 컴포넌트는 브라우저에 내장되어있는 `[<video>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video)` 태그를 렌더링합니다.

```js
function VideoPlayer({ src, isPlaying }) {
  // TODO: do something with isPlaying
  return <video src={src} />;
}
```

그러나, 브라우저의 `<video>`태그는 `isPlaying` prop을 갖고 있지 않습니다.
비디오를 조정하는 방법은 DOM 앨리먼트의 `play()`와 `pause()`을 수동으로 부르는 것 뿐입니다.
**`isPlaying`prop의 값과 동기화를 시켜야 하고, isPlaying 은 `play()` 와 `pause()`를 내부적으로 사용해 
현재 비디오를 실행_해야한다_는 것을 말해주어야합니다.**

먼저 `video` DOM 노드로부터 [ref를 얻어야](https://beta.reactjs.org/learn/manipulating-the-dom-with-refs)
합니다.

렌더링하면서 `play()`나 `pause()`를 부르고 싶은 마음이 들 수도 있지만, 그 방법은 옳지 않습니다:

<Code src="https://codesandbox.io/s/fjm8gc?file=/App.js&utm_medium=sandpack"/>

이 코드가 틀린 이유는 렌더링하면서 DOM으로 무언가를 하려고 시도했기 때문입니다.
리액트에서는 [렌더링은 JSX의 순수계산이어야만 하고](https://beta.reactjs.org/learn/keeping-components-pure)
DOM을 변경하거나 하는 부작용을 포함해서는 안됩니다.

더욱이, `VideoPlayer`가 처음으로 불릴 떄, DOM은 아직 존재하지 않습니다!
React는 JSX가 반환될 때까지 어떤 DOM이 생성될지 모르기 떄문에 `play()`나 `pause()`를 부를 DOM 노드가 아직 없습니다.

여기 해결책은 **렌더링 계산 밖으로 코드를 가져와서 `useEffect`를 사용한 부작용으로 감싸주는 것입니다.**

```js
import { useEffect, useRef } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

Effect에 DOM 업데이트를 감싸주면서, React가 화면을 먼저 업데이트하도록 해줄 수 있습니다.
그리고 나서 Effect가 돌아가죠.

`VideoPlayer`컴포넌트가 렌더링될 때 (처음이거나 다시 렌더링되는 경우 중 하나).
몇 가지 일들이 일어날 수 있습니다. 
먼저, React는 DOM안의 `<video>` 태그가 옳은 prop을 갖고 있는지 확인하면서 화면을 업데이트할 것입니다.
그리고 나서야 React는 Effect를 실행할 것입니다.
마지막으로, Effect가 `isPlaying` prop의 값에 따라 `play()`나 `pause()`를 부를 것입니다.

실행/멈춤을 여러번 눌러보고 비디오 플레이어가 어떻게 `isPlaying`값과 동기화되어서 작동하는지 확인해보세요.

<Code src="https://codesandbox.io/s/dvynjy?file=%2FApp.js&utm_medium=sandpack"/>

이 예시에서, React 상태와 동기화한 "외부 시스템"은 브라우저의 미디어 API였습니다. 
여러분은 과거의 React가 아닌 코드(jQuery 플러그인과 같은)를 선언적인 React 컴포넌트로 감싸줄 때도 비슷한 접근을 사용할 수 있습니다.

비디오 플레이어를 조정하는 것은 실제로 훨씬 더 복잡하다는 것을 알아두세요. `play()` 호출이 실패할 수도 있고, 사용자가 브라우저의 내장된 컨트롤 기능을 사용해서 실행하거나 멈출 수도 있습니다.
이 예시는 매우 간소화된 것입니다.

:::danger 주의할 점

기본적으로 Effeect는 매 렌더링 후에 돌아갑니다. 다음과 같은 코드가 왜 **무한루프를 생성하는 지**에 대한 이유입니다:

```js 
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```

Effect는 렌더링의 _결과_를 실행합니다. 상태를 설정하는 것은 렌더링을 _유발_합니다.
Effect에서 직접적으로 상태를 설정하는 것은 동력 콘센트의 전원을 스스로에게 꽂는 것과 같습니다.
Effect가 동작하고, 상태를 설정하고, 리렌더링을 일으키고, Effect가 동작하고, 다시 상태를 설정하고 이와 같은 일이 반복해서 일어납니다.

Effect는 컴포넌트를 _외부_ 시스템과 동기화해야합니다. 만약 외부 시스템이 없고 다른 상테에 기반한 몇 가지 상태를 변경하고 싶을 뿐이라면, [Effect가 필요 없을 수도 있습니다.](https://beta.reactjs.org/learn/you-might-not-need-an-effect)

:::

## 2단계: Effect의 의존성을 명확히 하기

기본적으로, Effect는 _모든_ 렌더링 후에 돌아갑니다. 종종 이는 **원하는 바가 아닐 수** 있습니다:

- 가끔 이 동작은 느립니다. 외부 시스템과 동기화하는 것은 항상 즉각적이지 않기 떄문에 불필요하다면 넘어가고 싶을 수 있습니다.
예를 들어, 모든 키입력마다 채팅 서버를 재연결 하고 싶지는 않을 것입니다.
- 가끔 이 동작은 잘못되었습니다. 예를 들어, 모든 키입력마다 컴포넌트에 fade-in 애니메이션을 넣고 싶지 않을 수 있습니다. 
이 에니메이션은 컴포넌트가 처음 나타날 때에만 동작해야 합니다.

이 문제를 증명하기 위해, 몇몇 개의 `console.log` 호출과 부모 컴포넌트의 상태를 업데이트 하는 텍스트 입력이 있는 이전에 사용한 예시가 있습니다.
타이핑이 어떻게 Effect를 계속 돌아가게 하는지 확인해보세요:

<Code src="https://codesandbox.io/s/z1hxjk?file=%2FApp.js&utm_medium=sandpack"/>

`useEffect` 호출을 할 때 두 번쨰 인자로 의존성 배열을 명시해서 불필요하게 Effect를 다시 돌아가게 하는 것을 피하도록 할 수 있습니다.
위 예시의 14번쨰 줄에 빈 `[]` 배열을 추가하는 것으로 시작해보세요:

```js 
 useEffect(() => {
    // ...
  }, []);
```

`React 훅인 useEffect가 `isPlaying` 의존성을 갖고 있지 않다는` 에러를 봐야합니다:

<Code src="https://codesandbox.io/s/dszumx?file=%2FApp.js&utm_medium=sandpack"/>

이 문제는 Effect 내부의 코드가 무엇을 할지 결정하기 위해 `isPlaying` prop에 _의존_하는 것입니다.
하지만 이 의존성은 명백하게 선언되지 않았습니다. 이 문제를 고치기 위해서는 의존성 배열에 `isPlaying`을 추가해보세요:

```js 
 useEffect(() => {
    if (isPlaying) { // It's used here...
      // ...
    } else {
      // ...
    }
  }, [isPlaying]); // ...so it must be declared here!
```

이제 모든 의존성이 선업되었기 떄문에 에러가 없습니다. `[isPlaying]`을 의존성 배열로 명시하는 것은
만약 `isPlaying`이 이전 렌더링의 했을 떄와 같으면 Effect를 재실행하지 말라고 React에게 말해주는 것입니다.
이 변화로 입력창에 입력하는 것은 Effect가 다시 실행되는 것을 막아주지만 실행/멈춤을 누르면 여전히 Effecet가 동작합니다.

<Code src="https://codesandbox.io/s/6o7zyc?file=%2FApp.js&utm_medium=sandpack"/>

의존성 배열은 여러 개의 의존성을 갖고 있을 수 있습니다.
React는 이전 렌더링동안 갖고 있던 값과 비교해서 명시한 _모든_ 의존성이 같으면 리렌더링을 하지 않습니다.
React는 `[Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)` 비교를 사용해서 의존 값들을 비교합니다.
더 자세한 내용은 [`useEffect` API](https://beta.reactjs.org/reference/react/useEffect#reference)를 확인해보세요.

**의존성을 "선택"할 수 없다는 것을 알아두세요.** 만약 명시해놓은 의존성들과 Effect 내부의 코드에 기반했을 떄 React가 생각하는 의존성이 일치하지 않는다면 lint error를 얻게 될 것입니다.
이는 코드의 버그를 잡는 데 도움이 됩니다. Effect가 몇 개의 값들을 사용하지만 그 값들이 변할 떄 Effect가 돌아가길 원하지 *않는다*면, [Effect코드가 그 의존성을 "필요"로 하지 않도록 직접 코드를 수정](https://beta.reactjs.org/learn/lifecycle-of-reactive-effects#what-to-do-when-you-dont-want-to-re-synchronize)해야 할 것입니다.

:::danger 주의할 점

의존성이 _없는_배열과 빈 `[]` 배열은 매우 다릅니다:

```js 
useEffect(() => {
  // 모든 렌더링마다 동작합니다.
});

useEffect(() => {
  // 마운트 될 때만 동작합니다. (컴포넌트가 나타날 떄)
}, []);

useEffect(() => {
  // 마운트 될 떄 *그리고 또* 지난 렌더링 이후로 a 또는 b가 변했을 때 동작합니다.
}, [a, b]);
```

다음 단계에서 "마운트"가 무엇을 의미하는지 더 자세히 알아 볼 것입니다. 

:::

:::note DEEP DIVE

### 왜 ref는 의존성 배열에서 빠지나요?

Effect는 `ref`와 `isPlaying` 둘 다 사용하고 있지만 `isPlaying`만 의존성 배열에 선언되어있습니다:

```js

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);

```

이는 `ref`객체는 _안정적인 동일성_을 갖고 있기 때문입니다:
React는 모든 렌더링에서 `useRef`를 호출할 때 [항상 같은 객체를 얻을 것](https://beta.reactjs.org/reference/react/useRef#returns)을 보장합니다.
그 객체는 절대 변하지 않기 때문에 Effect를 다시 실행하게 하지도 않을 것입니다.
따라서 ref 를 포함하는지 아닌지를 중요하지 않습니다. 포함해도 괜찮습니다:

```js

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying, ref]);

```

`useState`로 반환된 [`set`함수](https://beta.reactjs.org/reference/react/useState#setstate)도 안정적인 동일성을 갖고 있기 떄문에 의존성에서 제외된 것을 종종 보게 될 것입니다.
만약 linter가 에러 없이 의존성에서 제외한다면 안전한 것입니다.

항상 안정적인 의존성을 제외하는 것은 linter 가 그 객체가 안정적이라는 것을 "볼" 수 있을 때만 가능합니다.
예를 들어, 만약 `ref`가 부모 컴포넌트로부터 전달된다면 의존성 배열에 명시해야 합니다. 
왜냐하면 부모의 컴포넌트가 항상 같은 ref를 넘겨주는지, 아니면 여러개의 ref중의 하나를 조건부로 넘겨주는지 모를 수 있기 떄문에 명시하는 것이 좋습니다.
그래야만 Effect가 어떤 ref 가 전달되는 지 여부에 의존할 수 있습니다.

:::

## 3단계: 필요하다면 cleanup을 추가하세요

다른 예시를 고려해보세요. ChatRoom이 보일 떄마다 서버에 연결해야하는 `ChatRoom` 컴포넌트를 쓰고 있습니다.
여러분은 `connect()`와 `disconnect()`를 갖고 있는 객체를 돌려주는 API `createConnection()`을 받았습니다. 
사용자에게 보여지는 동안 컴포넌트를 어떻게 연결된 상태로 유지할 수 있을까요?

Effect 로직을 쓰는 것부터 시작합시다:

```
useEffect(() => {
  const connection = createConnection();
  connection.connect();
});

```

모든 리렌더링마다 채팅에 연결하는 것은 느리기 떄문에 의존성 배열을 추가해야합니다:

```js 
useEffect(() => {
  const connection = createConnection();
  connection.connect();
}, []);
```

**Effect 내부의 코드는 아무 prop이나 상태를 사용하지 않기 때문에 의존성 배열 `[]`(비어있음) 입니다. 
이는 React가 컴포넌트가 "마운트"할 때만 이 코드를 실행한다는 것을 말해줍니다. 다른 말로 화면에 처음 나타날 때를 의미합니다.**

이 코드를 실행해봅시다:

<Code src="https://codesandbox.io/s/mgymtb?file=%2FApp.js&utm_medium=sandpack"/>

Effect는 마운트 시 한번만 동작하기 떄문에 콘솔창에 `"✅ Connecting..."`이 한 번만 출력될 것이라고 예상할 수도 있습니다.
**하지만 콘솔을 확인해보면 `"✅ Connecting..."`은 두 번 출력됩니다. 왜 이런 일이 일어날까요?**

`ChatRoom` 컴포넌트가 다른 많은 화면들을 가진 더 큰 앱의 일부라고 상상해보세요. 
사용자는 `ChatRoom` 페이지에서 그들의 여행을 시작합니다. 컴포넌트는 마운트하고 `connection.connect()`를 부릅니다. 
사용자가 다른 화면으로 이동한다고 생각해보세요- 예를 들어, 설정 화면이요. `Chatroom` 컴포넌트는 언마운트 될 것입니다.
마지막으로, 사용자가 뒤로가기를 클릭하고 `ChatRoom`이 다시 마운트됩니다. 
이 마운트는 두 번째 연결을 만들 것입니다- 하지만 첫 번째 연결은 없어진 적이 없습니다! 
사용자가 앱을 둘러볼 때, 연결은 계속 쌓이고 있었습니다.

이와 같은 버그는 수동 테스트를 많이 돌려보지 않는 이상 놓치기 쉽습니다. 
빨리 발견하도록 하기 위해 React는 처음 마운트 한 후에 모든 컴포넌트를 다시 마운트 합니다.
**`"✅ Connecting..."` 로그를 두 번 보는 것은 진짜 문제를 확인할 수 있도록 도와줍니다: 코드가 컴포넌트가 언마운트 될 때 연결을 닫지 않고 있다는 것입니다.**

이 문제를 해결하기 위해, Effect에서 cleanup 함수를 돌려줍니다:

```js 
 useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []);
```

React는 Effec가 다시 돌아가기 전에, 그리고 컴포넌트가 내려가는 마지막 시점에(제거됩니다) cleanup 함수를 부를 것입니다. 
cleanup 함수가 실행될 때 무엇이 일어나는지 확인해봅시다:

<Code src="https://codesandbox.io/s/58bmg8?file=%2FApp.js&utm_medium=sandpack"/>

이제 개발 환경에서 세 개의 콘솔 로그를 보게 됩니다:

1. `"✅ 연결 중..."`
2. `"❌ 연결 해지됨."`
3. `"✅ 연결 중..."`

**이는 개발 환경에서 맞는 행동입니다.** 컴포넌트를 다시 마운트하면서 React는 앱을 돌아다니거나 뒤로 가는 것이 코드를 망가뜨리지 않았다는 것을 확인합니다.
연결을 해지하고 다시 연결하는 것은 정화하게 일어나야 할 일입니다! cleanup을 잘 구현할 때, Effect를 한번 돌리는 것과 Effect를 돌리고, cleanup함수를 돌리고, 다시 Effect를 실행하는 것 사이의 차이를 사용자가 볼 수 없어야 합니다.
React가 개발 환경에서 버그가 있는지 조사하고 있기 때문에 별도의 연결/연결 해지 호출 쌍이 있습니다.
이는 일반적인 일이기 때문에 없애려고 해서는 안됩니다.

**실제 환경에서는 `"✅ 연결 중..." `이 한번만 출력되는 것을 보실 수 있을 것입니다.**
컴포넌트를 다시 마운트하는 것은 개발자가 cleanup이 필요한 Effect를 찾을 수 있도록 도와주기 위해서만 일어납니다. 
개발 환경의 설정 중에서 [Strict Mode](https://beta.reactjs.org/reference/react/StrictMode)를 끌 수도 있지만, 추천하지 않습니다. 
이 설정은 위와 같은 많은 버그들을 찾을 수 있도록 해줍니다. 

## 개발할 때 Effect 가 두 번 실행되는 것을 어떻게 조절할까요?

React는 방금 전의 예시와 같은 버그를 찾도록 도와주기 위해 개발에서 컴포넌트를 의도적으로 다시 마운트합니다.
**올바른 질문은 "Effect를 어떻게 한 번만 실행할 수 있나요"가 아니라 "어떻게 Effect를 고쳐서 다시 마운트 된 후에도 동작하게끔 할 수 있나요"입니다.**

일반적으로 답은 cleanup 함수를 실행하는 것입니다. cleanup 함수는 Effect가 무엇을 하든간에 상관없이 멈추거나 다시 이전의 상태로 돌려놓아야 합니다.
경험상 사용자는 Effect가 한 번 실행된 것(production 환경으로)과 실행 -> cleanup-> 실행의 순서(개발에서 볼 수 있듯이)를 눈치챌 수 없어야 합니다.

앞으로 사용하게 될 Effect의 대부분은 아래 패턴 중 하나에 해당할 것입니다. 

### React가 아닌 위젯을 조정하는 것

가끔 React로 만들어지지 않은 UI 위젯을 추가할 필요가 있습니다. 예를 들어, 페이지에 지도 컴포넌트를 추가하고 싶다고 말해봅시다.
지도 컴포넌트는 `setZoomLevel()` 메소드를 갖고 있어야하고, React 코드 내부의 `zoomLevel`상태 변수와 동기화시키고 싶어할 것입니다.
Effect는 아래와 유사할 것입니다:

```js 
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

이 경우에는 cleanup 함수가 필요없다는 것을 확인하세요. 개발에서 React는 Effect를 두 번 부르지만 같은 값을 가진 `setZoomLevel`을 두 번 부르는 것은 아무 것도 하지 않기 때문에 문제가 되지 않습니다.
살짝 느려질 수는 있지만 개발 환경에서만 다시 마운트하는 것이고 배포된 상황에서는 일어나지 않을 것이기 때문에 문제가 되지 않습니다.

몇몇 API는 연속으로 두 번 부르는 것을 혀용하지 않을 수 잇습니다. 예를 들어, 내장되어있는 `[<dialog>](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement)` 엘리먼트의
`showModal`을 두 번 부르면 에러를 던집니다. cleanup함수를 사용해서 dialog를 닫을 수 있습니다:

```js 
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

개발할 때, Effect는 `showModal()`을 부르고 나서 즉시`close()`를 부르고, `showModal()`을 다시 부를 것입니다.
이는 배포 환경에서 보게 되듯이 사용자 입장에서 `showModal()`을 한번 부른 것과 같습니다.

### 이벤트를 구독하는 것

Effect가 무언가를 구독한다면 cleanup함수가 구독을 해지해야합니다:

```js 
useEffect(() => {
  function handleScroll(e) {
    console.log(e.clientX, e.clientY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

개발 환경에서, Effect는 `addEventListener()`를 부르고, 그 다음 즉시 `removeEventListener()`을 부른 다음, 다시 같은 핸들러로 `addEventListener()`를 호출합니다.
그래서 한번에 단 하나의 활성화된 구독만 있을 것입니다. 이는 사용자 입장에서 `addEventListener()`을 한번 부르는 것과 같은 행동이라는 것을 배포환경에서 볼 수 있을 것입니다.







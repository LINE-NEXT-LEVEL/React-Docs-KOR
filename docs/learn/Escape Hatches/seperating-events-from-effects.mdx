import {Code} from "../../../src/components/Code";

...

:::info DEEP DIVE
### 의존성 lint를 무시해도 괜찮을까요?
여러분은 아래 코드에서처럼 일부 코드에서 lint 규칙이 무시되고 있는걸 확인할 수 있습니다.

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems);
    // 🔴 아래와 같이 lint가 무시됩니다.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [url]);
  // ...
}

```

`useEffectEvent`가 React에서 안정적인 부분이 된 이후로부터 우리는 **절대 lint를 무시하지 않는 것을** 권장하고 있습니다.

Lint 규칙을 무시함으로써 발생하는 첫번째 부작용은, 여러분이 새로 작성한 의존성에 대해서 "반응"해야 한다고 React가 경고하지 않는다는 것입니다.
이전의 예시에서 여러분은 `url`을 의존성 배열에 추가해 React가 수정사항을 알려주길 원했습니다. 만약 lint를 끈다면 미래에 생길 수정사항에 대해 React가 더 이상 알려주지 않습니다.
그리고 이는 버그로 이어질 것입니다.

Lint를 껐을 때 생기는 또 다른 혼란스러운 버그도 있습니다. 예를 들어 `handleMove` 함수는 현재의 `canMove` 상태 변수를 읽고 커서를 따라갈지 말지를 결정하게끔 작성되어 있습니다.
하지만 `canMove`는 `handleMove` 안에서 항상 `true`일 것입니다.

왜 그런지 이해하셨나요?

<Code src="https://codesandbox.io/embed/agitated-smoke-mk2e2e?fontsize=14&hidenavigation=1&theme=dark" />

이 코드의 문제점은 의존성을 확인하는 lint가 꺼져있다는 것입니다. 만약 이 억제를 제거한다면 이 effect는 `handleMove` 함수에 의존하게 됩니다.
이건 말이 되죠. `handleMove`는 컴포넌트 내부에 선언되어 있기 때문에 반응형 변수라고 볼 수 있습니다. 모든 반응형 변수는 항상 의존성으로 관리되어야 합니다.
그렇지 않다면 언젠가 상한(stale) 상태가 될 것입니다!

이 코드를 작성한 사람은 React에게 effect는 어떤 반응형 변수에도 의존하지 않는다고 "거짓말"을 했습니다.
이로 인해 React는 `canMove` 함수(그리고 `handleMove` 함수)가 변경된 후에도 다시 싱크를 맞추지 않았던 것입니다.
React가 effect와 다시 싱크를 맞추지 않는다면, 리스너에 부착된 `handleMove` 함수는 최초에 렌더링되었을 때 생성된 `handleMove`일 것입니다.
그리고 이 `handleMove` 함수는 첫 렌더링시에 `canMove`가 `true`인 상태일때 만들어진 함수이므로, 영원히 `canMove`가 `true`인 채로 기억하고 있을 것입니다.

**lint를 무시하지 않는다면, 여러분은 상한(stale) 변수로 인해 발생하는 문제점들을 볼 일이 없을 것입니다.**

`useEffectEvent`와 함께라면, lint에게 "거짓말"할 필요가 없고, 코드는 여러분이 예상한대로 동작할 것입니다.

<Code src="https://codesandbox.io/embed/stupefied-bell-7km5vz?fontsize=14&hidenavigation=1&theme=dark" />

`useEffectEvent`가 항상 최고의 해답임을 의미하는 것은 아닙니다. lint를 끄는 것은 리액티브하게 동작하지 않는 코드에만 해야 합니다.
그리고 위 코드에서는 `canMove`에 대해 effect가 리액티브 하게 동작했으면 합니다. 이것이 Effect event를 추출한 이유입니다.

[Effect의 의존성 제거하기](https://react.dev/learn/separating-events-from-effects#:~:text=Read-,Removing%20Effect%20Dependencies,-for%20other%20correct)를 통해
lint를 억제하는 다른 올바른 대안에 대해서도 알아보세요.

:::


## Effect 이벤트의 제한사항

:::danger 작성중!
아래 섹션은 실제 안정된 React 버전으로 **배포되지 않은 실험적 API**에 대해 다루고 있습니다.
:::

Effect 이벤트는 여러분이 어떻게 사용하느냐에 따라 매우 제한적입니다.
- **Effect 내부에서만 호출해야 합니다.**
- **다른 컴포넌트나 hook에 전달해서는 안됩니다.**

예를 들어, 아래처럼 Effect 이벤트를 선언하거나 전달해서는 안됩니다.

```jsx
function Timer() {
  const [count, setCount] = useState(0);

  const onTick = useEffectEvent(() => {
    setCount(count + 1);
  });

  useTimer(onTick, 1000); // 🔴 주의: Effect event를 전달하지 마세요!

  return <h1>{count}</h1>
}

function useTimer(callback, delay) {
  useEffect(() => {
    const id = setInterval(() => {
      callback();
    }, delay);
    return () => {
      clearInterval(id);
    };
  }, [delay, callback]); // 의존성 배열에 "callback"이 무엇인지 구체적으로 적어야 합니다.
}
```

이 대신, Effect 이벤트를 항상 이를 사용하는 effect의 옆에 선언하세요.

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  useTimer(() => {
    setCount(count + 1);
  }, 1000);
  return <h1>{count}</h1>
}

function useTimer(callback, delay) {
  const onTick = useEffectEvent(() => {
    callback();
  });

  useEffect(() => {
    const id = setInterval(() => {
      onTick(); // ✅ Effect 내부에서 지역적으로만 호출하세요.
    }, delay);
    return () => {
      clearInterval(id);
    };
  }, [delay]); // "onTick" (Effect Event)가 무엇인지 의존성 배열에 명시할 필요가 없습니다.
}
```

Effect 이벤트는 리액티브 하지 않은 effect 코드의 "조각"입니다. 이들은 항상 이를 사용하는 effect의 옆에 있어야 합니다.

## 되짚어보기
- 이벤트 핸들러는 특정한 상호작용에 반응함으로써 동작합니다.
- Effect는 싱크가 필요한 경우에 동작합니다.
- 이벤트 핸들러 내부에 있는 로직은 리액티브 하지 않습니다.
- Effect 내부에 있는 로직은 리액티브 합니다.
- 리액티브하지 않은 로직을 effect에서 effect 이벤트로 옮길 수 있습니다.
- Effect 이벤트는 오직 effect 내부에서만 호출되어야 합니다.
- Effect 이벤트를 다른 컴포넌트나 훅에 전달하면 안됩니다.


:::note 문제에 도전해 보세요.
### 1. 업데이트 되지 않는 변수 고치기
이 `Timer` 컴포넌트는 매 초마다 꾸준히 증가하는 `count` 상태 변수를 가지고 있습니다. 이 변수의 증가하는 만큼은 `increment` 상태 변수에 저장되고 있습니다.
`increment` 상태 변수는 '+' 혹은 '-' 버튼을 통해 조절할 수 있습니다.

하지만 '+' 버튼을 아무리 많이 클릭해도 카운터는 매 초마다 하나씩만 증가할 뿐입니다.
이 코드는 무엇이 잘못되었을까요? 왜 `increment`는 항상 effect 코드 안에서 `1`일까요? 실수를 찾아 고쳐보세요.

<Code src="https://codesandbox.io/embed/wonderful-margulis-f7jq7n?fontsize=14&hidenavigation=1&theme=dark" />

**힌트**
이 코드를 고치기 위해서는 규칙을 따르는 것으로도 충분합니다.

**정답**
평소처럼 여러분은 effect 안에서 버그를 찾기 시작할겁니다. linter 억제가 잘못되진 않았는지부터 확인해보세요.

만약 lint를 억제하는 주석을 제거하면, React는 여러분에게 이 effect 코드의 의존성이 `increment`에 있지만 여러분이 React에게 이 코드가 어떤 리액티브한 변수에도 의존하지 않고 있다고 거짓말 하고 있음을 알려줄 것입니다.
`increment` 변수를 의존성 배열에 추가해주세요.

<Code src="https://codesandbox.io/embed/infallible-benz-0bx5sq?fontsize=14&hidenavigation=1&theme=dark" />

이제 `increment`가 변하면 React는 다시 effect와 싱크를 맞추고, interval을 초기화 시킬 것입니다.

### 2. 멈춰버린 카운터 고치기

이 `Timer` 컴포넌트는 매 초마다 증가하는 `count` 상태 변수를 가지고 있습니다. 이 변수의 증가하는 만큼은 `increment` 상태 변수에 저장되고 있습니다.
`increment` 상태 변수는 '+' 혹은 '-' 버튼을 통해 조절할 수 있습니다.
예를 들어, '+' 버튼을 아홉번 누르면 `count`는 매 초마다 1이 아닌 10만큼 증가됩니다.

하지만 작은 이슈가 있습니다. '+' 버튼 혹은 '-' 버튼을 초당 1회 이상 누르게 되면 타이머는 멈춘 것처럼 보입니다. 이는 오직 여러분이 어떤 버튼을 건드리든 1초 이후에 다시 재개됩니다.
왜 이런일이 일어나는지 알아보고, 타이머가 방해 없이 정확히 매 초 1씩 증가할 수 있도록 고쳐보세요.

<Code src="https://codesandbox.io/embed/shy-snow-yjdf5q?fontsize=14&hidenavigation=1&theme=dark" />

**힌트**
Effect가 `increment`에만 "반응"하도록 작성되어 있는것 같습니다.
`setCount`를 호출하기 위해 필요한 현재의 `increment`를 사용하는 라인은 정말 리액티브 해야 할까요?

**정답**
이 이슈는 effect 내부의 코드가 `increment` 상태 변수를 사용하기 때문에 발생합니다.
`increment`가 effect의 의존성 배열에 있는 한 `increment`의 모든 업데이트는 effect의 싱크를 다시 맞추게 됩니다. 이는 interval을 초기화하도록 만듭니다.
만약 이 이벤트가 발생하기 전에 계속 interval을 초기화 한다면, 타이머가 멈춘 것처럼 보일 것입니다.

이 문제를 해결하기 위해서는 `onTick` effect 이벤트를 effect 밖으로 추출해야 합니다.

<Code src="https://codesandbox.io/embed/confident-pateu-ovcsvi?fontsize=14&hidenavigation=1&theme=dark" />

`onTick`이 effect 이벤트이므로, 그 내부는 리액티브 하지 않습니다. `increment`의 변화는 어떤 effect도 트리거하지 않습니다.

### 3. 조절 불가능한 딜레이를 고쳐보세요.

이 예시에서 여러분은 interval의 딜레이를 조절할 수 있습니다. 이는 `delay` 상태 변수에 저장되고 두개의 버튼에 의해 업데이트 됩니다.
하지만 만약 `delay`가 1000 밀리세컨드(1초입니다)가 되도록 "plus 100 ms" 버튼을 누른다면 여전히 타이머가 매우 빠르게(매 100ms마다) 증가됨을 확인할 수 있습니다.
이는 여러분이 `delay`를 바꾸지 않은 것처럼 보입니다.
버그를 찾고 해결해보세요.

<Code src="https://codesandbox.io/embed/sharp-beaver-cs64ml?fontsize=14&hidenavigation=1&theme=dark" />

**힌트**
Effect 이벤트 내부의 코드는 리액티브 하지 않습니다. `setInterval`을 다시 호출하길 원하는 하는 다른 경우들이 있었나요?

**정답**
위 예시의 문제점은 `onMount` 코드가 실제로 무엇을 하는지 고려하지 않고 effect 이벤트로 추출했다는 것입니다.
Effect event는 코드의 일부를 리액티브 하지 않게 만들려 하는 등의 특별한 이유가 있을때만 추출되어야 합니다. 하지만 `setInterval`의 호출은 `delay` 상태 변수의 관점에서는 리액티브 해야 합니다.
`delay`가 변경되면 interval을 다시 시작하고 싶어하기 때문입니다. 이를 해결하기 위해서는 리액티브한 코드를 다시 effect의 내부로 이동시켜야 합니다.

<Code src="https://codesandbox.io/embed/relaxed-moore-2ndtb3?fontsize=14&hidenavigation=1&theme=dark" />

일반적으로 `onMount`와 같이 *타이밍*을 코드의 *목적*보다 더 집중하는 함수들에 대해 의심해야 합니다.
처음에는 "더 설명적"이라고 느껴질 수도 있지만 의도를 흐리게 합니다. 경험상 effect 이벤트들은 *유저*의 관점에서 반응하는 함수들입니다.
예를 들어, `onMessage`, `onTick`, `onVisit`이나 `onConnect` 같은 것들은 좋은 effect 이벤트의 이름들입니다.
이들의 내부 코드들은 대부분 리액티브할 필요가 없습니다.
반면에 `onMount`, `onUpdate`, `onUnmount`나 `onAfterRender` 같은 함수들은 너무 일반적이라 실수로 리액티브 *해야만 하는* 코드들을 그 안에 넣을 수도 있습니다.
코드가 실행되었을 때의 동작이 아닌 *이벤트가 발생했을때 유저가 어떻게 생각할지*를 고려해 이름을 붙어야 하는 이유입니다.

### 4. 늦은 알림 고치기

여러분이 채팅방에 입장했을 때 컴포넌트는 알림을 하나 보여줘야 합니다. 하지만 컴포넌트는 알림을 즉시 보여주지 않습니다.
대신 유저가 UI를 둘러볼 수 있도록 알림은 의도적으로 2초정도 딜레이 되어 있습니다.

이는 거의 동작하지만, 버그가 하나 있습니다. 드롭다운을 "general"에서 "travel"로 바꾸고, 또 다시 "music"으로 매우 빠르게 바꿔보세요.
충분히 빠르게 조작했다면 여러분은 (예상과 같이) 두개의 알림을 보게 되지만, *두 알림*은 모두 "Welcome to music"이라고 나타납니다.

"general"에서 "travel"로, 그리고 "music"으로 매우 빠르게 변경했을 때 두개의 알림이 보이되 첫번째 알림은 "Welcome to travel"로, 두번째는 "Welcome to music"으로 보이도록 수정해보세요.
(추가 도전 과제로 이미 알림에 올바른 채팅방이 표시되었다고 가정하고 코드를 변경하여 마지막 알림만 표시되도록 해보세요.)

<Code src="https://codesandbox.io/embed/brave-wright-ih4jjw?fontsize=14&hidenavigation=1&theme=dark" />

**힌트**
여러분의 effect는 어떤 채팅방과 연결되었는지 *이미* 알고 있습니다. Effect 이벤트에 전달하고 싶은 추가적인 정보가 더 있나요?

**정답**
여러분의 Effect 이벤트 내부에서는 `roomId`가 *시간 effect 이벤트*가 호출되었을 때의 값으로 남아 있습니다.

Effect 이벤트는 2초의 딜레이를 두고 호출됩니다. 만약 travel에서 music 채팅방으로 빠르게 이동하면, 그때까지 travel 채팅방의 알림이 보여지고, `roomId`는 이미 `"music"`입니다.
이것이 두 알림이 모두 "Welcome to music"을 보여주는 이유입니다.

이 이슈를 수정하기 위해서는, *최신의* `roomId`를 effect 이벤트 내부에서 읽도록 하는 것이 아니라, 아래의 `connectedRoomId`처럼 effect 이벤트의 파라미터로 만들어야 합니다.
그리고 `roomId`를 `onConnect(roomId)`를 호출함으로써 전달합니다.

<Code src="https://codesandbox.io/embed/xenodochial-star-m5xvfj?fontsize=14&hidenavigation=1&theme=dark" />

`roomId`를 `"travel"`로 변경한 effect는(`"travel"` 채팅방에 연결되었습니다) `"travel"`의 알림을 보여줄 것입니다.
`roomId`를 `"music"`으로 변경한 effect는(`"music"` 채팅방에 연결되었습니다) `"music"`의 알림을 보여줄 것입니다.
다른 말로 하면 effect로부터 추출한(리액티브한) `connectedRoomId`는 항상 최신의 `theme` 변수를 사용하게 됩니다.

추가 과제를 해결하기 위해서는 알림의 timeout ID를 저장하고 effect의 cleanup function을 통해 초기화해줍니다.

<Code src="https://codesandbox.io/embed/modest-sun-699knw?fontsize=14&hidenavigation=1&theme=dark" />

이렇게 하면 채팅방을 변경할때 이미 예약된(아직 노출되지 않은) 알림이 취소됩니다.

:::
import {Code} from "../../../src/components/Code";

# Effect 의존성을 제거하기

여러분이 Effect를 작성할 때, linter는 Effect 의존성 리스트에 있는 모든 반응형 값들(props와 상태 같은)을 여러분이 포함시켰다는 것을 확인할 것입니다.
이는 여러분의 Effect가 컴포넌트의 가장 최신의 props 그리고 상태와 동기화되어있다는 것을 증명합니다.
불필요한 의존성은 Effect가 너무 자주 실행되거나 무한대로 실행되도록 만듭니다.
Effect에서 불필요한 의존성을 점검하고 제거하기 위해 아래 안내를 따라가세요.

:::note You will learn

- 무한 실행을 야기시키는 Effect 의존성을 고치는 방법
- 의존성을 제거하고 싶을 때 해야 할 일
- Effect에서 "값"에 반응하는 것 없이 값을 읽는 방법
- 의존성에서 객체와 함수를 피해야 하는 이유와 방법
- 의존성 linter를 막는 것이 위험한 이유와 대체할 방법

:::

## 의존성은 코드와 부합해야 한다

Effect를 작성할 때, Effect가 해야 할 일이 무엇이든 [시작하고 멈추는](https://react.dev/learn/lifecycle-of-reactive-effects#the-lifecycle-of-an-effect) 방법을 기술합니다.

```js
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  	// ...
}
```

그리고 나서, Effect 의존성을 비어두면(`[]`), linter는 올바른 의존성을 제안할 것입니다:

<Code src="https://codesandbox.io/s/ypr7lf?file=%2FApp.js&utm_medium=sandpack" />

linter가 말하는 것에 맞추어서 의존성을 채워나갑니다:

```js
function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ 모든 의존성이 선언되어 있습니다
  // ...
}
```

[Effect는 반응형 값에 "반응"합니다.](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values)
`roomId`가 반응형 값((재렌더링으로 변할 수 있는 것))이기 때문에, linter는 의존성에 `roomId`를 넣었는지 확인합니다.
만약 `roomId`가 다른 값을 받았다면, React는 Effect를 재동기화할 것입니다.
이는 채팅이 선택된 방과 연결되게 해주고 드롭다운에 "반응"하게 해줍니다.


<Code src="https://codesandbox.io/s/fyltuv?file=%2FApp.js&utm_medium=sandpack" />

### 의존성을 제거하기 위해 의존성이 아니란 것을 증명해라

Effect의 의존성을 "선택" 할 수 없다는 것에 주목하세요.
Effect 코드에 사용되는 모든 *반응형 값*은 의존성 배열에 선언되어야만 합니다.
의존성 배열은 주변 코드에 의해 정해집니다:

```js
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) { // 반응형 값입니다
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Effect는 반응형 값을 읽습니다
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ 따라서 여러분은 Effect의 의존성에 반응형 값을 넣어야만 합니다
  // ...
}
```

[반응형 값](https://react.dev/learn/lifecycle-of-reactive-effects#all-variables-declared-in-the-component-body-are-reactive)은 컴포넌트 내부에 바로 선언된 모든 변수들과 함수들 그리고 props을 포함합니다.
`roomId`가 반응형 값이기 때문에 여러분은 의존성 배열에서 이 값을 제거할 수 없습니다. 
linter가 제거하는 것을 허락하지 않습니다:

```js
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // 🔴 React hook useEffect가 의존성을 누락했습니다: 'roomId'
  // ...
}
```

linter는 올바르게 지적합니다! `roomId`는 시간이 지나면서 바뀔 수 있기 때문에 `roomId`는 여러분의 코드에서 버그가 될 수 있습니다.

**의존성을 제거하기 위해서는 이 값이 의존성에 필요하지 않은 것이라고 linter에게 증명해야 합니다.**
예를 들어, 여러분은 반응적이지 않고 재렌더링에도 변하지 않는다는 것을 증명하기 위해 `roomId`를 컴포넌트 밖으로 이동시킬 수 있습니다.

```js
const serverUrl = 'https://localhost:1234';
const roomId = 'music'; // 더이상 반응형 값이 아닙니다

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // ✅ 모든 의존성이 선언되었습니다
  // ...
}
```

이제 `roomId`는 반응형 값이 아니고 재렌더링에도 변하지 않기 때문에 의존성에 있을 필요가 없습니다.

<Code src="https://codesandbox.io/s/exqi0o?file=%2FApp.js&utm_medium=sandpack" />

이것이 바로 여러분이 [빈 의존성 배열](https://react.dev/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means)(`[]`)을 작성할 수 있는 이유입니다.
Effect가 정말로 어떠한 반응형 값에 의존적이지 *않기* 때문에 Effect는 컴포넌트의 prop 또는 상태 변화에도 재실행될 *필요가 없습니다.*

### 의존성을 바꾸기 위해 코드를 바꾸기

작업 흐름에서 패턴을 눈치챘을 지도 모릅니다.

1. 첫번째, Effect 또는 반응형 값이 선언된 방식의 **코드를 바꾸기**
2. 그 다음, **여러분이 변경한 코드에 부합하도록** 의존성을 수정하고 linter를 따르기
3. 의존성 배열에 만족하지 못한다면, **첫번째 단계로 다시 돌아가기**(그리고 다시 코드를 바꾸기)


마지막 부분이 중요합니다.
**의존성을 변경하기 원한다면, 첫번째로 주변 코드를 변경하세요.**
[Effect 코드에서 사용되는 모든 반응형 값들의 배열](https://react.dev/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency)로 의존성 배열을 생각할 수 있습니다.
여러분은 그 배열에 무엇을 넣을지 고를 수 없습니다.
배열은 코드를 *설명합니다.*
의존성 배열을 변경하기 위해서는 코드를 변경하세요.

이는 마치 방정식을 푸는 것과 비슷합니다.
목표(예를 들어 의존성을 제거하는 것)를 향하기 시작했다면 그 목표에 부합한 코드를 "찾을" 필요가 있습니다.
모두가 방정식을 푸는 것을 재미있어하지 않는데, Effect를 작성하는 것에서도 똑같이 적용됩니다!
다행히도, 아래 여러분이 시도할 수 있는 몇가지 팁들이 있습니다.

:::danger Pitfall

작성해놓은 코드가 있다면, 여러분의 몇몇 Effect가 아래와 같이 linter를 제한하는 코드를 가지고 있을지 모릅니다.

```js
useEffect(() => {
  // ...
  // 🔴 아래와 같이 linter를 제한하는 것을 피하세요:
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);

```

의존성이 코드와 부합하지 않을 때, 버그를 일으킬 위험이 매우 높습니다.
linter를 제한함으로서 Effect가 의존하는 값들에 대해서 React에 "거짓말"하는 것입니다.

대신에, 아래에 있는 기술들을 사용하세요.
:::

:::info Deep Dive
의존성 linter를 제한하는 것이 왜 위험한가요?

linter를 제한하는 것은 찾고 수정하기 어려운 직관적이지 않은 버그가 생기게 만듭니다.
아래 예시가 있습니다.

<Code src="https://codesandbox.io/s/w5p3bc?file=%2FApp.js&utm_medium=sandpack"/>

Effect가 "마운트하는 경우"에만 실행되기를 원한다고 해봅시다.
[빈 배열(`[]`)](https://react.dev/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means)인 경우 그렇게 할 수 있다는 것을 읽었습니다. 따라서 linter를 무시하고 강제로 `[]`을 의존성으로 두었다고 합시다.

이 counter는 두개의 버튼으로 정한 양만큼 매초마다 증가하도록 설계되어 있습니다.
하지만, 여러분이 이 Effect가 어떤 것에도 의존성을 갖고 있지 않다고 React에게 "거짓말"을 한 이후부터 React는 초기 렌더링에서 정의한 `onTick` 함수를 계속해서 사용할 것입니다.
렌더링 동안, `count`는 `0`이었고 `증가분`은 `1`이었습니다.
첫 렌더링에서 정의된 `onTick`은 항상 매초마다 `setCount(0 + 1)`을 호출하고 여러분은 항상 `1`을 볼 것입니다.
이러한 버그는 다양한 컴포넌트들에 퍼져 있을 경우 수정하기 더욱 어려워집니다.

linter를 무시하는 것 말고 더 나은 방안이 항상 있을 것입니다!
이 코드를 수정하기 위해, 여러분은 의존성 배열에 `onTick`을 추가하면 됩니다.
간격은 오직 처음 한번만 설정된다는 것을 확실히 하기 위해, [`onTick`을 Effect Event로 만듭니다](https://react.dev/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events).

**의존성 lint 에러를 컴파일 에러로 보는 것을 추천드립니다. 만약 linter를 제한하지 않는다면 위와 같은 버그를 볼 일이 없을 것입니다.**
이 페이지의 남은 부분들은 이러한 버그와 다른 버그 상황들에 대한 대안책을 기술하고 있습니다.

:::

## 불필요한 의존성을 제거하기

코드에 맞추어서 Effect의 의존성을 정리할 때마다, 의존성 배열을 주의깊게 보세요.
이 의존성 중 어떤 것이라도 변할 때 Effect가 재실행되는 것이 말이 되나요? 가끔 대답은 "아니"입니다.

- 다른 조건에서 Effect의 *다른 부분을* 재실행하기를 원할 수 있습니다.
- 몇몇 의존성 값의 변경에 "반응"하기 보다 가장 최신 값을 읽기만 하고 싶을 수 있습니다.
- 의존성에 객체 또는 함수가 있어 *의도하지 않았는데* 의존성이 매우 자주 바뀔 수도 있습니다.

올바른 해결방법을 찾기 위해서 Effect와 관련된 몇가지 질문에 대해 대답할 필요가 있습니다.
차근차근 알아봅시다.

### 코드를 이벤트 핸들러로 옮겨야 하나요?

여러분이 생각해야 할 첫번째는 이 코드가 Effect에 있어야 하는지 없어도 되는지에 관한 것입니다.

form을 생각해 보세요.
제출할 때, `submitted` 상태 변수를 `true`로 설정합니다.
POST 요청을 보내고 알림을 보여줄 필요가 있습니다.
여러분은 `submitted`가 `true`가 되면 "반응"하도록 이 로직을 Effect 안에 넣었습니다.

```js
function Form() {
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    if (submitted) {
      // 🔴 피하기: Effect 내부에 이벤트 기반 로직
      post('/api/register');
      showNotification('Successfully registered!');
    }
  }, [submitted]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}
```

이후, 알림 메시지를 현재 테마에 맞게 스타일링하고 싶다면, 여러분은 현재 테마를 알아야 합니다.
`theme`이 컴포넌트 내부에 선언되어있기 때문에 반응형 값이며 여러분은 의존성에 추가해야 합니다.

```js
function Form() {
  const [submitted, setSubmitted] = useState(false);
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (submitted) {
      // 🔴 피하기: Effect 내부에 이벤트 기반 로직
      post('/api/register');
      showNotification('Successfully registered!', theme);
    }
  }, [submitted, theme]); // ✅ 모든 의존성들이 선언되었습니다

  function handleSubmit() {
    setSubmitted(true);
  }  

  // ...
}
```

이렇게 하면서 여러분은 버그를 생성했습니다.
form을 제출하고나서 흑백 테마를 번갈아서 바꾸어 보는 것을 상상해 보세요.
`theme`은 변경되고 Effect는 재실행되고 같은 알림을 또 보여줄 것입니다!

**여기서 문제는 POST 요청과 알림을 보내는 로직이 Effect에 있어서 안된다는 것입니다.**
form을 *제출*하면 POST 요청을 보내고 알림을 보여주기를 원합니다. 그리고 이 로직은 특별한 상호작용입니다.
특정 상호작용에 대해서 코드를 실행하기 위해서는 그 코드를 이벤트 핸들러 안에 넣어야 합니다.

```js
function Form() {
  const theme = useContext(ThemeContext);

  function handleSubmit() {
    // ✅ Good: Event-specific logic is called from event handlers
    post('/api/register');
    showNotification('Successfully registered!', theme);
  }  

  // ...
}
```

이벤트 핸들러 안에 있는 코드는 이제 반응형이 아닙니다. 따라서 이 코드는 사용자가 form을 제출할 때에만 실행합니다.
[이벤트 핸들러와 Effect 중 고르기](https://react.dev/learn/separating-events-from-effects#reactive-values-and-reactive-logic)와 [불필요한 Effect를 지우는 법](https://react.dev/learn/you-might-not-need-an-effect)에 대해 더 읽어 보세요.

### Effect가 몇몇 관계없는 일들을 하고 있나요?

여러분이 스스로에게 질문해야 할 다음 질문은 Effect가 관계없는 일을 하고 있는지입니다.

도시와 지역을 고르는 배송주문 form을 만들고 있다고 상상해 보세요.
`country`를 선택하면 서버에서 `cities` 목록을 가져오고 dropdown에 `cites` 목록을 보여줍니다.

```js
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ✅ 모든 의존성은 선언되어 있습니다

  // ...

```

[Effect에서 데이터를 가져오는](https://react.dev/learn/you-might-not-need-an-effect#fetching-data) 좋은 예시입니다.
`country` prop에 따라서 `cities` 상태를 동기화할 수 있습니다.
여러분은 이 로직을 이벤트 핸들러로 만들 수 없습니다. `ShippingForm`이 보이는 순간과 `country`가 바뀔 때마다(어떤 상호작용이 있는가와 상관없이) 데이터를 가져와야 하기 때문입니다.

두번째 선택 박스인 도시 지역을 추가했다고 가정해 봅시다. 현재 선택된 `city`에 맞는 `areas` 데이터를 가져와야 합니다.
같은 Effect 내부에 지역 목록을 부르는 두번째 `fetch`를 추가해야 할지도 모릅니다.

```js
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    // 🔴 피하기: 하나의 Effect는 두개의 독립된 과정을 동기화하고 있습니다
    if (city) {
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
    }
    return () => {
      ignore = true;
    };
  }, [country, city]); // ✅ 모든 의존성이 선언되었습니다

  // ...
```

하지만, Effect가 `city` 상태 변수를 사용하기 때문에 여러분은 의존성 배열에 `city`를 추가해야만 합니다.
이제 문제가 발생합니다. 사용자가 다른 도시를 선택할 때, Effect는 재실행되고 `fetchCities(country)`가 실행됩니다.
결과적으로 여러 번 도시 목록을 불필요하게 불러오게 됩니다.

이 코드의 문제는 두가지 연관이 없는 과정들을 함께 동기화하고 있는 것입니다.

1. `country` prop을 기반으로 `cities` 상태를 동기화하기를 원합니다.
2. `city` 상태를 기반으로 `areas` 상태를 동기화하기를 원합니다.

로직을 두 개의 Effect로 분리하고 각각의 Effect는 동기화될 필요가 있는 값에 반응합니다.

```js
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ✅ 모든 의존성이 선언되었습니다

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);
  useEffect(() => {
    if (city) {
      let ignore = false;
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
      return () => {
        ignore = true;
      };
    }
  }, [city]); // ✅ 모든 의존성이 선언되었습니다

  // ...
```

이제 첫번째 Effect는 `country`가 변경할 때에만 재실행됩니다. 두번째 Effect는 `city`가 변경될 때에만 재실행됩니다.
여러분은 목적으로 두 개의 Effect를 분리했습니다.
두개의 값은 각각 다른 Effect에 의해서 동기화됩니다.
두 개의 분리된 Effect는 각각 분리된 의존성 배열을 가지고 있기 때문에 서로 의도치 않게 트리거하지 않습니다.

마지막 코드는 처음 코드보다 더 길지만 여전히 Effect를 분리하는 것이 더 정확합니다.
[각각의 Effect는 독립적인 동기화 과정을 가지고 있어야 합니다.](https://react.dev/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process)
이 예시에서, 한개의 Effect를 제거해도 다른 Effect 로직에 영향을 주지 않습니다.
이는 Effect가 각각 다른 것을 동기화하고 있음을 의미하고 잘 분리했다는 것을 의미합니다.
중복에 대해서 고민하고 있다면 [custom Hook으로 반복적인 로직을 추출](https://react.dev/learn/reusing-logic-with-custom-hooks#when-to-use-custom-hooks)함으로서 코드를 향상시킬 수 있습니다.






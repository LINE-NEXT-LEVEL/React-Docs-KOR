import {Code} from "../../../src/components/Code";

## 컴포넌트의 body 영역에 선언되어있는 모든 변수들은 reactive 합니다. 

prop과 상태만이 reactive한 값이 아닙니다. 그것을 가지고 계산한 값들 또한 reactive합니다.
만약 prop 또는 상태가 변한다면, 컴포넌트는 리랜더링 될 것이고 prop과 상태에서 계산된 값도 변할 것입니다. Effect에 사용되는 컴포넌트 body 내부의 모든 변수들이 Effect 의존성 리스트에 있어야 하는 이유입니다. 

사용자가 채팅 서버를 선택할 수 있다고 말해봅시다. 하지만 환경설정에서 기본 서버를 설정할수도 있습니다.
이미 [context](https://react.dev/learn/scaling-up-with-reducer-and-context)에 설정 상태를 넣어서 context에서 `settings`를 읽을 수 있다고 가정해봅시다. 이제 props에서 가져온 선택된 서버와 기본 서버에 기반해 `serverUrl`을 계산합니다.

```js
function ChatRoom({ roomId, selectedServerUrl }) { // roomId 는 reactive 힙니다.
  const settings = useContext(SettingsContext); // settings 는 reactive 힙니다.
  const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl 는 reactive 힙ㄴ;디/
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Effect 에서 roomId 와 serverUrl 을 읽습니다.
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // 둘 중 하나가 변할때마다 다시 동기화할 필요가 있습니다!
  // ...
}
```

이 예시에서, `serverUrl`은 prop이나 상태 변수가 아닙니다. 그것은 렌더링 동안에 계산하는 일반 변수입니다. 하지만 렌더링 동안에 계산되기 때문에, 리랜더링이 때문에 별할 수 있습니다. serverUrl이 reactive한 이유입니다. 

**컴포넌트 안의 모든 값들(props, 상태, 그리고 body 안에 있는 변수들을 포함해서)은 reactive합니다. 어떤 reactive한 값도 리렌더링에 변화할 수 있기 때문에 Effect의 의존성으로 reactive한 값들을 포함시킬 필요가 있습니다.**

다른 말로, Eeffect는 컴포넌트의 body에 있는 모든 값들에 "반응"합니다.

:::info DEEP DIVE

### 전역 값 또는 가변 값이 종속성이 될 수 있나요?

가변적인 변수 값(글로벌 변수 포함)은 reactive 하지 않습니다.

**[`location.pathname`](https://developer.mozilla.org/en-US/docs/Web/API/Location/pathname)과 같은 가변적인 변수 값은 종속성일 수 없습니다.** 이것은 가변적이기 때문에 React 렌더링 데이터 흐름 밖에서 언제든지 변경될 수 있습니다. 변경해도 컴포넌트가 다시 렌더링되지 않습니다. 따라서 종속성에 지정한 경우에도 그 값이 변경될 때 Effect를 다시 동기화할 수 없습니다. 렌더링 중(의존성을 계산할 때) 가변 데이터를 읽으면 [렌더링의 순수성](https://react.dev/learn/keeping-components-pure)이 깨지기 때문에 이는 React의 규칙도 위반합니다. 대신, [useSyncExternalStore](https://react.dev/learn/you-might-not-need-an-effect#subscribing-to-an-external-store)를 사용하여 외부의 가변적인 변수 값을 읽고 구독해야 합니다.

**[ref.current](https://react.dev/reference/react/useRef#reference)와 같은 가변적인 변수 또는 ref.current에서 읽은 값도 종속성이 될 수 없습니다.** `useRef`에서 반환된 ref 객체 자체는 종속성일 수 있지만 `현재` 속성은 의도적으로 변경할 수 있습니다. 이 기능을 사용하면 [리랜더링을 유발하지 않고 무언가를 추적할 수 있습니다](https://react.dev/learn/referencing-values-with-refs). 그러나 변경해도 리랜더링을 일으키지 않으므로 reactive한 값이 아니며, 변경될 때 React는 Effect를 다시 실행해야하는지 알 수 없습니다.

이 페이지에서 아래에서 알게 될 것처럼, linter는 이러한 문제를 자동으로 확인합니다.

:::

## React는 모든 reactive한 값을 종속성으로 지정했는 지 확인합니다.

linter가 [React용으로 설정된](https://react.dev/learn/editor-setup#linting) 경우 Effect 코드에서 사용되는 모든 reactive한 값이 종속성으로 선언되는지 확인합니다. 예를 들어 roomId와 serverUrl이 모두 reactive 때문에 이 코드는 lint 오류입니다:

<Code src="https://codesandbox.io/s/u2grt7?file=%2FApp.js&utm_medium=sandpack">

이것은 React 오류처럼 보일 수 있지만 React는 코드의 버그를 지적하고 있습니다. `roomId`와 `serverUrl` 모두 시간이 지남에 따라 변경될 수 있지만, 변경될 때 Effect를 다시 동기화하는 것을 잊을 것입니다. 사용자가 UI에서 다른 값을 선택한 후에도 초기 `roomId` 및 `serverUrl`에 계속 연결되도록 남아있어야 합니다.

버그를 수정하려면 linter의 제안에 따라 `roomId` 및 `serverUrl`을 Effect의 종속성으로 지정합니다:

```js
function ChatRoom({ roomId }) { // roomId is reactive
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl 은 reactive 힙니다.
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]); // ✅ 모든 의존성이 선언되었습니다.
  // ...
}
```

위의 샌드박스에서 수정해보세요. linter 오류가 사라지고 필요할 때 채팅을 다시 연결하는지 확인해보세요.

:::note Note

경우에 따라 React는 값이 컴포넌트 내부에서 선언되더라도 값이 변경되지 않는다는 것을 _알고 있습니다_. 예를 들어, `useState`에서 반환된 [`set` 함수](https://react.dev/reference/react/useState#setstate)와 `[useRef](https://react.dev/reference/react/useRef)`에서 반환된 ref 개체는 안정적이며, 리랜더링할 때 변경되지 않습니다. 안정된 값은 reactive하지 않으므로 배열에서 제외할 수 있습니다. 그들을 포함하는 것은 허용됩니다. 변하지 않기 때문에, 중요하지 않습니다.

:::

## 재동기화를 원하지 않을 때 해야 할 것

이전 예제에서는 `roomId`와 `serverUrl`을 종속성으로 배열하여 lint 오류를 해결했습니다.

**그러나 이러한 값이 reactove힌 값이 아니라는 것을 linter에 "증명"할 수 있습니다.** 즉, 리랜더링의 결과로 변경될 수 없다는 것을요. 예를 들어, `serverUrl`과 `roomId`가 렌더링에 의존하지 않고 항상 동일한 값을 가지는 경우 컴포넌트 외부로 이동할 수 있습니다. 이제 종속성일 필요가 없습니다:

```js
const serverUrl = 'https://localhost:1234'; // serverUrl 는 reactive 하지 않습니다
const roomId = 'general'; // roomId 는 reactive 하지 않습니다

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ✅ 모든 의존성이 선언되었습니다
  // ...
}
```

_Effect 내부로_ 이동할 수도 있습니다. 렌더링 시 계산되지 않으므로 reactive하지 않습니다:

```js
function ChatRoom() {
  useEffect(() => {
    const serverUrl = 'https://localhost:1234'; // serverUrl 는 reactive 하지 않습니다
    const roomId = 'general'; // roomId 는 reactive 하지 않습니다
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ✅ 모든 의존성이 선언되었습니다
  // ...
}
```

**Effect는 reactive한 코드 블록입니다.** 사용자가 내부에서 읽은 값이 변경되면 다시 동기화됩니다. 상호 작용당 한 번만 실행되는 이벤트 핸들러와 달리 효과는 동기화가 필요할 때마다 실행됩니다.

**종속성을 "선택"할 수 없습니다.** 종속성은 효과에서 읽은 모든 [reactive한 값](https://react.dev/learn/lifecycle-of-reactive-effects#all-variables-declared-in-the-component-body-are-reactive)을 포함해야 합니다. linter가 이를 적용합니다. 이로 인해 무한 루프와 같은 문제가 발생하고 효과가 너무 자주 다시 동기화될 수 있습니다. linter를 억제해서 이 문제를 해결해서는 안됩니다! 대신 시도해 볼 내용은 다음과 같습니다:

- **Effect가 독립적인 동기화 프로세스를 나타내는지 확인합니다.** Effect가 아무것도 동기화하지 않으면 [불필요한 렌더링일 수 있습니다.](https://react.dev/learn/you-might-not-need-an-effect). 여러 개의 독립적인 것을 동기화하는 경우 [코드를 나누세요.](https://react.dev/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process).

- **prop이나 상태의 최신 값을 "반응"하지 않은 채 읽고 효과를 다시 동기화하려면 Effect를 reactive한 부분(Effect에서 유지)과 reactove하지 않는 부분(Effect 이벤트라고 하는 부분으로 추출)으로 나눌 수 있습니다.** [이벤트와 Effect를 구분하는 방법에 대해 읽어보십시오.](https://react.dev/learn/separating-events-from-effects)

- **객체 및 함수을 종속성으로 사용하는 것을 피하세요.** 렌더링하는 동안 객체와 함수를 만든 다음 Effect에서 읽으면 렌더링마다 객체와 함수가 달라집니다. 이렇게 하면 Effect가 매번 다시 동기화됩니다. [Effects에서 불필요한 종속성을 제거하는 방법에 대해 자세히 알아보십시오.](https://react.dev/learn/removing-effect-dependencies)



:::info 주의할 점

linter는 당신의 친구이지만, 그 힘은 제한되어 있습니다. linter는 의존성이 잘못된 경우에만 알 수 있습니다. linter는 각각의 사건을 해결하는 최선의 방법을 알지 못합니다. linter가 종속성을 제안하지만 이를 추가하면 루프가 발생하는 경우 linter를 무시해야 하는 것은 아닙니다. 이 값이 reactive하지 않고 종속적일 필요가 없도록 Effect 내부(또는 외부)의 코드를 변경해야 합니다.

기존 코드베이스가 있는 경우 다음과 같이 linter를 억제하는 효과가 있을 수 있습니다:

```js
useEffect(() => {
  // ...
  // 🔴 linter를 이렇게 억누르는 것을 피하세요:
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
```

[다음 페이지](https://react.dev/learn/removing-effect-dependencies)에서는 규칙을 위반하지 않고 이 코드를 수정하는 방법에 대해 배울 것입니다. 항상 고칠만한 가치가 있습니다!

:::

## 되짚어보기

- 컴포넌트는 마운트, 업데이트 및 마운트 해제할 수 있습니다.
- 각 Effect에는 주변 컴포넌트와 별도의 수명 주기가 있습니다.
- 각 Effect는 시작 및 중지할 수 있는 별도의 동기화 프로세스를 설명합니다.
- Effect를 쓰고 읽을 때 컴포넌트의 관점(마운트, 업데이트 또는 마운트 해제 방법)보다는 각 개별 Effect의 관점(동기화를 *시작* 및 *중지*하는 방법)에서 생각합니다.
컴포넌트 본문 내부에 선언된 값은 "reactive"합니다.
- reactive한 값은 시간이 지남에 따라 변경될 수 있으므로 Effect를 다시 동기화해야 합니다.
- linter는 Effect 내에서 사용되는 모든 reactive한 값이 종속성으로 지정되었는지 확인합니다.
- linter에 의해 빨간줄이 그어진 모든 오류는 정당한 이유가 있습니다. 규칙을 어기지 않도록 코드를 수정하는 방법은 항상 있습니다.

## 도전해보기

### 1. 모든 키 입력마다 다시 연결되는 것을 수정하기

이 예시에서 `ChatRoom` 컴포넌트는 컴포넌트가 마운트될 때 채팅 룸에 연결하고, 마운트 해제될 때 연결을 끊고, 다른 채팅 룸을 선택할 때 다시 연결합니다. 이 동작은 올바르므로 계속 작동해야 합니다.

하지만, 한 가지 문제가 있습니다. 하단의 메시지 상자 입력에 입력할 때마다 ChatRoom은 채팅에 다시 연결됩니다. (콘솔을 지우고 입력해보면 이를 알 수 있습니다.) 이 문제가 발생하지 않도록 문제를 해결해보세요.

<Code src="https://codesandbox.io/s/8p4qro?file=%2FApp.js&utm_medium=sandpack">

### 힌트

이 Effect를 위해 종속성 배열을 추가해야 할 수 있습니다. 어떤 종속성이 있어야 될까요?

### 해답

이 Effect에는 종속성 배열이 전혀 없으므로 다시 렌더링할 때마다 다시 동기화됩니다. 먼저 종속성 배열을 추가합니다. 그런 다음 Effect에서 사용되는 모든 reactive한 값이 배열에 지정되어 있는지 확인합니다. 예를 들어 `roomId`는 (prop이기 때문에) reactove히므로 배열에 포함되어야 합니다. 이렇게 하면 사용자가 다른 채팅방을 선택할 때 대화가 다시 연결됩니다. 반면에 `serverUrl`은 컴포넌트 외부에서 정의됩니다. 이것이 배열에 포함될 필요가 없는 이유입니다.

<Code src="https://codesandbox.io/s/rp5m1k?file=%2FApp.js&utm_medium=sandpack">

### 2. 스위치를 켜고 끄는 것을 동기화하기

이 예시에서 Effect는 윈도우 [`pointermove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointermove_event) 이벤트를 구독하여 화면의 분홍색 점을 이동합니다. 미리 보기 영역 위를 맴돌거나 (모바일 장치에 있는 경우 화면을 터치하여) 분홍색 점이 어떻게 이동하는지 확인합니다.

체크박스도 있습니다. 체크박스을 선택하면 `canMove` 상태 변수가 전환되지만 이 상태 변수는 코드 어디에서도 사용되지 않습니다. `canMove`가 false일 때(체크박스가 선택 취소됨) 점이 이동을 중지하도록 코드를 변경해야합니다. 체크박스를 다시 켠 후에 (`canMove`를 true로 설정하면) 확인란이 다시 이동해야합니다. 즉, 점이 이동할 수 있는지 여부는 체크박스가 선택되어 있는지 여부와 동기화된 상태로 유지되어야 합니다.

<Code src="https://codesandbox.io/s/s9xp8g?file=%2FApp.js&utm_medium=sandpack">

### 힌트

조건부로 Effect를 선언할 수 없습니다. 그러나 Effect 내부의 코드는 조건을 사용할 수 있습니다!

### 해답

한 가지 답은 `setPosition` 호출을 `if(canMove) {... }` 조건안에서 부르는 것입니다:

<Code src="https://codesandbox.io/s/18j4mw?file=%2FApp.js&utm_medium=sandpack">

대안으로는 `if(canMove) {... }` 조건을 *이벤트 구독* 로직으로 감쌀 수 있습니다:

<Code src="https://codesandbox.io/s/4bevbk?file=%2FApp.js&utm_medium=sandpack">

이 두 경우 모두 `canMove`는 Effect 내부에서 읽은 reactive한 변수입니다. 따라서 Effect 종속성 목록에 이 값을 지정해야 합니다. 이렇게 하면 값이 변경될 때마다 Effect가 다시 동기화됩니다.

### 3. 오래된 값 오류를 조사하기

이 예에서 분홍색 점은 체크박스가 켜져 있을 때 이동해야 하며 체크박스가 꺼져 있을 때 이동을 중지해야 합니다. 이에 대한 논리는 이미 구현되었습니다. `handleMove` 이벤트 핸들러는 `canMove` 상태 변수를 확인합니다.

그러나 어떤 이유로 `handleMove` 내부의 `canMove` 상태 변수는 "오래된 값"으로 표시됩니다. 체크박스를 선택 취소한 후에도 항상 true입니다. 이것이 어떻게 가능한 걸까요? 코드의 오류를 찾아 수정해보세요.

<Code src="https://codesandbox.io/s/rbklij?file=%2FApp.js&utm_medium=sandpack">

### 힌트

linter 규칙이 억제되는 것이 보이면 억제를 없애세요! 거기가 보통 실수하는 곳입니다.

### 해답

원래 코드의 문제는 종속성 linter를 억제하는 것이었습니다. 억제를 제거하면 이 Effect가 `handleMove` 기능에 따라 달라진다는 것을 알 수 있습니다. 이는 의미가 있습니다. `handleMove`는 컴포넌트 본체 내부에서 선언되므로 reactive한 값이 됩니다. 모든 reactive한 값을 종속성으로 지정해야 합니다. 그렇지 않으면 시간이 지남에 따라 낡은 값이 될 수 있습니다!

원래 코드의 작성자는 Effect가 reactive힌 값에 의존하지 않는다고 말하며 반응에 "거짓말"을 했습니다(`[]`). 이것은 React가   `canMove` 변경 후 Effect를 다시 동기화하지 않은 이유입니다(`handleMove`도 같이). React가 Effect를 다시 동기화하지 않았기 때문에 리스너로 첨부된 `handleMove`는 초기 렌더 중에 생성된 `handleMove` 함수입니다. 초기 렌더 동안 `canMove`는 true였으며, 이 때문에 초기 렌더링에서 생긴 `handleMove`는 해당 값을 영원히 볼 수 있습니다.

**linter를 억제하지 않으면 오래된 값에 문제가 발생하지 않습니다.** 이 버그를 해결하는 몇 가지 다른 방법이 있지만 항상 linter 억제를 제거하는 것부터 시작해야 합니다. 그런 다음 코드를 변경하여 lint 오류를 해결합니다.

Effect 종속성을 [`handleMove`]로 변경할 수 있지만 모든 렌더에 대해 새로 정의된 함수가 되므로 종속성 배열에서 제거하는 것이 좋습니다. 그러면 *다시 렌더링할 때마다 Effect가 다시 동기화됩니다.*

<Code src="https://codesandbox.io/s/w134i4?file=%2FApp.js&utm_medium=sandpack">

이 해답은 이상적이지는 않습니다. Effect 안에 `console.log('Resubscribing')`를 넣으면 리렌더할 때마다 다시 구독하는 것을 알 수 있습니다. 재구독은 빠르지만, 그렇게 자주 하는 것은 피하는 것이 좋을 것입니다.

`handleMove` 기능을 Effect 내부로 이동하는 것이 더 좋습니다. 그러면 `handleMove`는 reactive한 값이 아니므로 Effect가 함수에 의존하지 않습니다. 대신 이펙트 내부에서 코드가 읽히는 `canMove`에 의존해야 합니다. 이제 Effect가 `canMove` 값과 동기화된 상태로 유지되므로 원하는 동작과 일치합니다:

<Code src="https://codesandbox.io/s/kw7vqn?file=%2FApp.js&utm_medium=sandpack">

### 4. 스위치 연결 고치기

이 예에서 `chat.js`의 채팅 서비스는 두 가지 다른 API를 제공합니다:`createEncryptedConnection` 와 `createUnencryptedConnection`입니다. 루트 `App` 컴포넌트는 사용자가 암호화 사용 여부를 선택할 수 있도록 한 다음 해당 API 메서드를 하위 `ChatRoom` 컴포넌트에 `createConnection` prop으로 전달합니다.

처음에는 콘솔 로그에 연결이 암호화되지 않았다고 표시됩니다. 체크박스를 켜 보십시오: 아무 일도 일어나지 않습니다. 그러나 선택한 룸을 변경한 후 대화가 다시 연결되면 (콘솔 메시지에서 볼 수 있듯이) 암호화를 사용 가능으로 설정합니다. 이것은 버그입니다. 체크박스를 바꾸면 대화가 다시 연결되도록 버그를 수정합니다.

<Code src="https://codesandbox.io/s/f3ygk9?file=%2FChatRoom.js&utm_medium=sandpack">

### 힌트

linter 억제는 항상 의심스럽습니다. 버그가 될까요?

### 해답 

linter 억제를 제거하면 linter 오류가 나타납니다. 문제는 `createConnection`이 prop이기 때문에 reactive한 값이라는 것입니다. 시간이 지남에 따라 변경될 수 있습니다! (실제로 사용자가 체크박스를 선택하면 부모 컴포넌트가 `createConnection` prop의 다른 값을 전달합니다.) 이것이 의존성이어야 하는 이유입니다. 배열에 포함하여 버그를 수정합니다:

<Code src="https://codesandbox.io/s/wezb5n?file=%2FChatRoom.js&utm_medium=sandpack">

`createConnection`이 종속성인 것은 맞습니다. 그러나 누군가가 앱 컴포넌트를 편집하여 인라인 함수를 이 prop의 값으로 전달할 수 있기 때문에 이 코드는 약간 취약합니다. 이 경우 앱 컴포넌트가 다시 렌더링될 때마다 값이 달라지므로 Effect가 너무 자주 다시 동기화될 수 있습니다. 이 문제를 방지하려면 `isEncrypted`을 대신 전달할 수 있습니다:

<Code src="https://codesandbox.io/s/bq4voj?file=%2FChatRoom.js&utm_medium=sandpack">

이 버전에서는 `App` 컴포넌트가 함수 대신 boolean prop을 전달합니다. Effect 내에서 사용할 함수를 결정합니다. `createEncryptedConnection`와 `createUnencryptedConnection` 둘 다 컴포넌트 밖에서 선언되기 때문에 reactive하지 않고 종속성일 필요가 없습니다. 이에 대한 자세한 내용은 [Effect 종속성 제거](https://react.dev/learn/removing-effect-dependencies)에서 확인할 수 있습니다.

### 5. 연속된 셀렉트박스 채우기

이 예시에서는 두 개의 셀렉트박스가 있습니다. 하나의 셀렉트박스에서 사용자는 행성을 선택할 수 있습니다. 다른 셀렉트박스를 통해 사용자는 해당 행성의 위치를 선택할 수 있습니다. 두 번째 셀렉트박스는 아직 작동하지 않습니다. 두번째 셀렉트 박스가 선택된 행성의 장소들을 보여주도록 하세요.

첫 번째 셀렉트박스의 작동 방식을 확인합니다. /planets API 호출의 결과로 `planetList` 상태를 채웁니다. 현재 선택한 행성의 ID는 `planetId` 상태 변수에 유지됩니다. `placeList` 상태 변수가 `"/planets/" + planetId + "/places"` API 호출의 결과로 채워지도록 코드를 추가할 위치를 찾아야 합니다.

이 권한을 적용할 경우 행성을 선택하면 플레이스 목록이 채워집니다. 행성을 변경하면 플레이스 목록이 변경됩니다.

<Code src="https://codesandbox.io/s/k1cdux?file=%2FApp.js&utm_medium=sandpack"/>

### 힌트

두 개의 독립적인 동기화 프로세스가 있으면 두 개로 나눠진 Effect를 작성해야 합니다.

### 해답

두 가지 독립적인 동기화 프로세스가 있습니다:

- 첫 번째 셀렉트 박스는 원격 행성 목록에 동기화됩니다.
- 두 번째 셀렉트 박스는 현재 `planetId`에 대한 원격 위치 목록에 동기화됩니다.
이것이 두 개의 개별 Effect로 설명하는 것이 타당한 이유입니다. 다음은 이러한 작업을 수행하는 방법의 예입니다:

<Code src="https://codesandbox.io/s/g3oym4?file=%2FApp.js&utm_medium=sandpack"/>

이 코드는 약간 반복적입니다. 하지만, 그것이 하나의 Effect로 결합해야하는 좋은 이유는 아닙니다! 이렇게 하면 Effect의 두 종속성을 하나의 목록으로 결합해야 합니다. 그런 다음 행성을 변경하면 모든 행성의 목록이 다시 가져옵니다. Effect는 코드 재사용을 위한 도구가 아닙니다.

대신 반복을 줄이기 위해 `useSelectOptions`와 같은 사용자 지정 Hook에 몇 가지 논리를 추출할 수 있습니다:

<Code src="https://codesandbox.io/s/lwkyjo?file=%2FApp.js&utm_medium=sandpack"/>

샌드박스에서 `useSelectOptions.js` 탭을 확인하여 작동 방식을 확인합니다. 이상적으로는 사용자가 작성하든 커뮤니티가 작성하든 간에 응용프로그램의 대부분의 Effect는 사용자 정의 hook으로 대체되어야 합니다. 사용자 지정 hook은 동기화 로직을 숨겨 호출 컴포넌트가 Effect를 알지 못하도록 합니다. 앱에서 작업을 계속하면서 선택할 수 있는 hook들을 개발하게 되고, 결국 컴포넌트에 Effect를 자주 기록할 필요가 없게 됩니다.
<!doctype html>
<html lang="ko" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-learn/Escape Hatches/referencing-values-with-refs">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Ref를 이용해 값을 기억하기 | React Docs KOR</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://line-next-level.github.io/React-Docs-KOR/docs/learn/Escape Hatches/referencing-values-with-refs"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Ref를 이용해 값을 기억하기 | React Docs KOR"><meta data-rh="true" name="description" content="컴포넌트가 어떤 정보를 &quot;기억&quot;하게 만들면서 그 정보가 새로운 렌더링을 유발하지 않기를 원한다면, ref를 사용해보세요."><meta data-rh="true" property="og:description" content="컴포넌트가 어떤 정보를 &quot;기억&quot;하게 만들면서 그 정보가 새로운 렌더링을 유발하지 않기를 원한다면, ref를 사용해보세요."><link data-rh="true" rel="icon" href="/React-Docs-KOR/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://line-next-level.github.io/React-Docs-KOR/docs/learn/Escape Hatches/referencing-values-with-refs"><link data-rh="true" rel="alternate" href="https://line-next-level.github.io/React-Docs-KOR/docs/learn/Escape Hatches/referencing-values-with-refs" hreflang="ko"><link data-rh="true" rel="alternate" href="https://line-next-level.github.io/React-Docs-KOR/docs/learn/Escape Hatches/referencing-values-with-refs" hreflang="x-default"><link rel="stylesheet" href="/React-Docs-KOR/assets/css/styles.2d3a33e4.css">
<link rel="preload" href="/React-Docs-KOR/assets/js/runtime~main.16dcfed8.js" as="script">
<link rel="preload" href="/React-Docs-KOR/assets/js/main.ae80d2f5.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="본문으로 건너뛰기"><a href="#" class="skipToContent_fXgn">본문으로 건너뛰기</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/React-Docs-KOR/"><div class="navbar__logo"><img src="/React-Docs-KOR/img/logo.svg" alt="React Docs Beta KOR" class="themedImage_ToTc themedImage--light_HNdA"><img src="/React-Docs-KOR/img/logo.svg" alt="React Docs Beta KOR" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">React Docs Beta KOR</b></a><a class="navbar__item navbar__link" href="/React-Docs-KOR/docs/learn/installation/add-react-to-website">learn</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="맨 위로 스크롤하기" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/React-Docs-KOR/docs/learn/Quick Start/thinking-in-react">GET STARTED</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/React-Docs-KOR/docs/learn/Describing the UI/describing-the-ui">LEARN REACT</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/React-Docs-KOR/docs/learn/Describing the UI/describing-the-ui">Describing the UI</a><button aria-label="접을 수 있는 사이드바 분류 &#x27;Describing the UI&#x27; 접기(펼치기)" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/React-Docs-KOR/docs/learn/Adding Interactivity/adding-interactivity">Adding Interactivity</a><button aria-label="접을 수 있는 사이드바 분류 &#x27;Adding Interactivity&#x27; 접기(펼치기)" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/React-Docs-KOR/docs/learn/Managing State/managing-state">Managing State</a><button aria-label="접을 수 있는 사이드바 분류 &#x27;Managing State&#x27; 접기(펼치기)" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/escape-hatches">Escape Hatches</a><button aria-label="접을 수 있는 사이드바 분류 &#x27;Escape Hatches&#x27; 접기(펼치기)" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/referencing-values-with-refs">Ref를 이용해 값을 기억하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/manipulating-the-dom-with-refs">Ref를 사용해 돔 조작하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/synchronizing-with-effects">Effect 를 동기화하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/you-might-not-need-an-effect">Effect가 필요하지 않을 가능성</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/lifecycle-of-reactive-effects">React적인 Effect의 생명주기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/seperating-events-from-effects">Effects에서 이벤트 분리하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/removing-effect-dependencies">Effect 의존성을 제거하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/reusing-logic-with-custom-hooks">커스텀 훅으로 로직 재사용하기</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="홈" class="breadcrumbs__link" href="/React-Docs-KOR/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">LEARN REACT</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/React-Docs-KOR/docs/learn/Escape Hatches/escape-hatches"><span itemprop="name">Escape Hatches</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Ref를 이용해 값을 기억하기</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">이 페이지에서</button></div><div class="theme-doc-markdown markdown"><h1>Ref를 이용해 값을 기억하기</h1><p>컴포넌트가 어떤 정보를 &quot;기억&quot;하게 만들면서 그 정보가 <a href="https://beta.reactjs.org/learn/render-and-commit" target="_blank" rel="noopener noreferrer">새로운 렌더링을 유발</a>하지 않기를 원한다면, <em>ref</em>를 사용해보세요.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>여러분이 배울 것</div><div class="admonitionContent_S0QG"><ul><li>컴포넌트에 ref를 추가하는 법</li><li>ref의 값을 업데이트하는 법</li><li>ref가 상태와 다른 점</li><li>ref를 안전하게 사용하는 법</li></ul></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="컴포넌트에-ref를-추가하기">컴포넌트에 ref를 추가하기<a class="hash-link" href="#컴포넌트에-ref를-추가하기" title="제목으로 바로 가기">​</a></h2><p>React의 <code>useRef</code> 훅을 import해서 컴포넌트에 ref를 추가할 수 있습니다:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword module" style="color:#00009f">import</span><span class="token plain"> </span><span class="token imports punctuation" style="color:#393A34">{</span><span class="token imports"> useRef </span><span class="token imports punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword module" style="color:#00009f">from</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;react&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>컴포넌트 내부에서 <code>useRef</code> 훅을 부르고 기억하고 싶은 초기값을 인수 하나로 넘겨줍니다.
예를 들어, 아래 코드는 ref에 0을 넘겨 주었습니다.</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> ref </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useRef</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>useRef</code>는 아래와 같이 객체를 넘겨줍니다:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token literal-property property" style="color:#36acaa">current</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// The value you passed to useRef</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>// 이미지</p><p><code>ref.current</code> 특성을 통해 ref의 현재 값에 접근할 수 있습니다.
이 값은 의도적으로 변경 가능합니다, 즉 그 값을 읽고 변경할 수 있다는 것을 의미합니다.
React가 추적하지 못하는 컴포넌트의 비밀 저장소와 같습니다.
(즉, ref가 React의 단방향 데이터 흐름에서 &quot;벗어났다&quot;는 것을 의미합니다. 벗어난 것들에 대한 글이 더 많이 있습니다.)</p><p>이 코드에서 버튼은 매번 클릭할 때마다 <code>ref.current</code>를 늘릴 것입니다.</p><iframe src="https://codesandbox.io/s/2yh3vt?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>ref는 숫자를 가리키지만, <a href="https://beta.reactjs.org/learn/state-a-components-memory" target="_blank" rel="noopener noreferrer">상태</a>와 같이 문자열, 객체, 또는 함수 중 어떤 것이든 나타낼 수 있습니다.
상태와 달리, ref는 읽고 수정할 수 있는 <code>current</code> 특징을 가진 순수 JavaScrpt 객체입니다.</p><p>**컴포넌트가 매 증가마다 리렌더링되지 않는다&quot;는 것에 주목하세요.
상태와 같이, ref는 리렌더링 사이에 React에 의해 유지됩니다.
하지만, 상태를 업데이트하는 것은 컴포넌트를 리렌더링시킵니다. ref를 변경하는 것은 리렌더링이 일어나지 않습니다!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="예시-스톱워치-만들기">예시: 스톱워치 만들기<a class="hash-link" href="#예시-스톱워치-만들기" title="제목으로 바로 가기">​</a></h2><p>하나의 컴포넌트에서 ref와 상태를 같이 사용할 수 있습니다.
예시로, 사용자가 버튼을 누름으로서 시작하거나 멈출 수 있는 스톱워치를 만들어 봅시다.
사용자가 &quot;시작&quot;을 누른 후 얼마나 시간이 지났는지 보여주기 위해, 언제 시작 버튼이 눌렸고 현재 시간이 언제인지를 계속해서 추적해야 합니다.
**이 정보는 렌더링 동안 사용되므로 상태에 저장하고 있어야 합니다&quot;:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">startTime</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> setStartTime</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword null nil" style="color:#00009f">null</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">now</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> setNow</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword null nil" style="color:#00009f">null</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>사용자가 &quot;시작&quot;을 누를 때, 10ms마다 시간이 업데이트되게 하기 위해 <code>setInterval</code>을 사용할 것입니다.</p><iframe src="https://codesandbox.io/s/240gtb?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>&quot;멈춤&quot; 버튼이 눌렸을 때, <code>now</code> 상태 변수를 업데이트하는 것을 멈추기 위해 기존의 interval 함수를 취소할 필요가 있습니다.
<a href="https://developer.mozilla.org/en-US/docs/Web/API/clearInterval" target="_blank" rel="noopener noreferrer"><code>clearInterval</code></a>을 통해 가능하지만, 이전에 사용자가 시작버튼을 눌렀을 때 <code>setInterval</code>을 부르면서 반환된 interval ID를 <code>clearInterval</code>에 주어야 합니다.
어딘가에서 interval ID를 유지해야 합니다.
<strong>interval ID는 렌더링동안 사용되지 않기 때문에, ref에 ID를 저장할 수 있습니다</strong>:</p><iframe src="https://codesandbox.io/s/4w6yio?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>정보의 일부가 렌더링 동안 사용될 때는 정보를 상태에 저장하세요.
정보의 일부가 이벤트함수에만 필요하고 변경하는 것이 리렌더링을 필요로 하지 않을 때, ref를 사용하는 것이 더 효율적입니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="ref와-상태-사이의-차이점들">ref와 상태 사이의 차이점들<a class="hash-link" href="#ref와-상태-사이의-차이점들" title="제목으로 바로 가기">​</a></h2><p>아마도 ref를 상태보다 덜 &quot;엄격한&quot; 것으로 보고있을지도 모릅니다. 예를 들어, 상태 설정 함수를 항상 사용해야만 하는 것 대신에 ref를 변경할 수 있습니다.
하지만 대부분의 경우에 상태를 사용하게 됩니다.
Ref는 여러분이 종종 필요로 하지 않는 이상 현상입니다.
아래 상태와 ref를 비교한 표입니다:</p><table><thead><tr><th>refs</th><th>state</th></tr></thead><tbody><tr><td><code>useRef(initialValue)</code>는 <code>{ current: initialValue }</code>를 반환합니다</td><td><code>useState(initialValue)</code>는 상태 변수의 현재 값과 상태 설정 함수를 반환합니다 (<code>[value, setValue]</code>)</td></tr><tr><td>ref 값을 변경해도 리렌더링이 발생하지 않습니다.</td><td>상태 값을 변경하면 리렌더링이 발생합니다.</td></tr><tr><td>수정 가능 - <code>current</code>의 값을 렌더링 과정에서 벗어나서 수정하고 업데이트할 수 있습니다.</td><td>&quot;수정 불가능&quot; - 리렌더링 큐에 넣어 상태변수를 변경하기 위해서 상태 설정 함수를 사용해야만 합니다.</td></tr><tr><td>렌더링 동안 <code>crrent</code> 값을 읽거나 써서는 안됩니다.</td><td>어느 때든 상태를 읽을 수 있습니다. 하지만, 각 렌더는 변하지 않는 본인만의 상태 <a href="https://beta.reactjs.org/learn/state-as-a-snapshot" target="_blank" rel="noopener noreferrer">스냅샷</a>을 가지고 있습니다.</td></tr></tbody></table><p>상태로 실행되는 카운터 버튼이 있습니다:</p><iframe src="https://codesandbox.io/s/l7j2nh?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p><code>count</code> 값이 보이기 때문에 상태값을 사용하는 게 맞습니다.
<code>count</code>가 <code>setCount()</code>로 값이 정해질 때, React는 컴포넌트를 리렌더링하고 화면은 새로운 숫자를 반영해 업데이트됩니다.</p><p>ref로 실행되게 만든다면, React는 컴포넌트를 리렌더링하지 않고 숫자가 변경되는 것을 볼 수 었습니다!
버튼을 클릭해도 <strong>문구가 업데이트되지 않는 것</strong>을 보세요:</p><iframe src="https://codesandbox.io/s/q0irh4?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>렌더링 동안 <code>ref.current</code>를 읽는 것이 신뢰할 수 없는 코드를 만드는 이유입니다. 만약 렌더링 동안 읽어야 한다면, 상태를 대신 사용하세요.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Deep Dive</div><div class="admonitionContent_S0QG"><h3 class="anchor anchorWithStickyNavbar_LWe7" id="useref는-내부에서-어떻게-동작할까">useRef는 내부에서 어떻게 동작할까?<a class="hash-link" href="#useref는-내부에서-어떻게-동작할까" title="제목으로 바로 가기">​</a></h3><p><code>useState</code>와 <code>useRef</code> 모두 React에 의해 제공되지만, 원칙적으로 <code>useRef</code>는 <code>useState</code>를 바탕으로 실행될 수 있습니다.
React의 내부에서 <code>useRef</code>가 아래와 같이 동작된다고 생각해볼 수 있습니다.</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// Inside of React</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useRef</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">initialValue</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">ref</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> unused</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token literal-property property" style="color:#36acaa">current</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> initialValue </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> ref</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>첫번째 렌더링 동안, <code>useRef</code>는 <code>{ current: initialValue }</code>를 반환합니다.
이 객체는 React에 의해 저장되면서 다음 렌더동안 같은 객체가 반환됩니다.
이 예시에서 상태 재설정 함수가 사용되지 않는 것에 주목하세요.
상태 재설정 함수는 불필요합니다. 그 이유는 <code>useRef</code>는 항상 같은 객체를 반환해야 되기 때문입니다.</p><p>React는 <code>useRef</code>를 기본적으로 제공하는데 실제 상황에서 충분히 많이 사용되기 때문입니다.
여러분은 ref를 상태 재설정 함수를 가지지 않는 일반적인 상태 변수로 생각할 수 있습니다.
객체 중심 프로그래밍에 익숙하다면, ref는 <code>this.something</code> 대신에 <code>somethingRef.current</code>를 쓰는 것과 같이 instance field와 비슷합니다.</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="ref를-사용하는-경우">ref를 사용하는 경우<a class="hash-link" href="#ref를-사용하는-경우" title="제목으로 바로 가기">​</a></h2><p>컴포넌트가 React에서 &quot;벗어날&quot; 필요가 있고 외부 API(컴포넌트의 표시에 영향을 주지 않는 브라우저 API)와 소통할 때 보통 ref를 사용합니다.
아래와 같이 몇 가지 흔하지 않은 경우들이 있습니다:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" target="_blank" rel="noopener noreferrer">timeout ID</a>를 저장하기</li><li><a href="https://beta.reactjs.org/learn/manipulating-the-dom-with-refs" target="_blank" rel="noopener noreferrer">다음 장</a>에서 다룰 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element" target="_blank" rel="noopener noreferrer">DOM 요소</a>를 저장하고 조작하기</li><li>JSX를 조작할 필요가 없는 객체들을 저장하기</li></ul><p>만약 컴포넌트가 어떤 값을 저장하면서 렌더링 로직에 영향을 주지 않는다면, ref를 선택하세요.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="ref를-사용한-좋은-예시들">ref를 사용한 좋은 예시들<a class="hash-link" href="#ref를-사용한-좋은-예시들" title="제목으로 바로 가기">​</a></h2><p>아래 원칙들을 따르면 컴포넌트는 더욱 예측 가능해질 것입니다:</p><ul><li><strong>ref를 탈출구로 여기세요.</strong> Ref는 외부 시스템 또는 브라우저 API를 이용해 작업할 때 유용합니다. 앱 로직과 데이터 흐름의 대부분을 ref에 의존하게 만들었다면 당신의 접근에 대해 다시 생각해 보세요.</li><li><strong>렌더링 동안 <code>ref.current</code>를 읽거나 쓰지 마세요.</strong> 렌더링 동안 몇몇 정보가 필요하다면, <a href="https://beta.reactjs.org/learn/state-a-components-memory" target="_blank" rel="noopener noreferrer">상태</a>를 사용하세요.
React는 <code>ref.current</code>가 언제 변경되는지 모르기 때문에, 렌더링동안 <code>ref.current</code>를 읽는 것은 컴포넌트의 행동을 예측하는 것을 어렵게 만들 뿐입니다.
(이에 대한 예외로 첫번째 렌더링동안 ref를 한번만 설정하는 <code>if (!ref.current) ref.current = new Thing()</code> 같은 코드입니다.)</li></ul><p>Ref는 React 상태가 가진 한계들을 갖고 있지 않습니다.
예를 들어, 상태는 <a href="https://beta.reactjs.org/learn/state-as-a-snapshot" target="_blank" rel="noopener noreferrer">매 렌더링의 스냅샷</a>처럼 동작하고 <a href="https://beta.reactjs.org/learn/queueing-a-series-of-state-updates" target="_blank" rel="noopener noreferrer">동기적으로 업데이트되지도 않습니다</a>.
하지만 ref의 현재 값을 변경할 때, 그 값은 바로 변경됩니다:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ref</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">current</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">5</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">ref</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">current</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 5</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이는 <strong>ref 자체가 일반적인 JavaScript 객체</strong>이며 JavaScript 객체와 똑같이 작동하기 때문입니다.</p><p>ref를 이용해 작업할 때 <a href="https://beta.reactjs.org/learn/updating-objects-in-state" target="_blank" rel="noopener noreferrer">변경을 피하는 것</a>을 걱정할 필요가 없습니다.
여러분이 변경하는 객체가 렌더링에 사용되지 않는 한, React는 ref 또는 ref의 내용물에 여러분이 무슨 일을 하든 관심을 갖지 않습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="ref와-dom">Ref와 DOM<a class="hash-link" href="#ref와-dom" title="제목으로 바로 가기">​</a></h2><p>ref에 어떠한 값이든 넣을 수 있습니다. 하지만, 가장 흔한 사용법은 DOM 요소를 넣는 것입니다.
예를 들어, 계획적으로 input에 포커스를 두기를 원한다면 ref는 편리합니다.
JSX의 <code>ref</code> 속성에 ref를 넘겨줄 때, <code>&lt;div ref={myRef}&gt;</code>와 같이, React는 <code>myRef.current</code>에 대응하는 DOM 요소를 넣을 것입니다.
<a href="https://beta.reactjs.org/learn/manipulating-the-dom-with-refs" target="_blank" rel="noopener noreferrer">Ref로 DOM 조작하기</a>에서 이 부분에 대해 더 알아볼 수 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="되짚어보기">되짚어보기<a class="hash-link" href="#되짚어보기" title="제목으로 바로 가기">​</a></h2><ul><li>Ref는 렌더링에 사용되지 않는 값들을 저장하는 탈출구입니다. 사용되어야 하는 경우는 드뭅니다.</li><li>Ref는 <code>current</code>라 불리는 단일특성을 가진 순수 JavaScript 객체입니다. <code>current</code>의 값은 읽고 변경될 수 있습니다.</li><li><code>useRef</code> 훅으로 ref를 React에서 받을 수 있습니다.</li><li>상태와 같이, ref는 컴포넌트의 리렌더링 사이에 정보를 유지할 수 있도록 해줍니다.</li><li>상태와 달리, ref의 <code>current</code> 값을 변경하는 것은 리렌더링을 유발하지 않습니다.</li><li>렌더링 동안 <code>ref.current</code>를 읽거나 쓰지 마세요. 이는 컴포넌트를 더 예측하기 어렵게 만듭니다.</li></ul><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>문제에 도전해보세요</div><div class="admonitionContent_S0QG"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-고장난-채팅-입력을-고치세요">1. 고장난 채팅 입력을 고치세요<a class="hash-link" href="#1-고장난-채팅-입력을-고치세요" title="제목으로 바로 가기">​</a></h2><p>메시지를 입력하고 &quot;보내기&quot; 버튼을 클릭하세요. &quot;보냈다!&quot; 창을 보기 전에 3초의 지연이 있다는 것을 볼 수 있습니다.
이 지연동안 &quot;취소하기&quot; 버튼을 볼 수 있습니다. 이 &quot;취소하기&quot; 버튼은 &quot;보냈다!&quot; 메시지가 나타나는 것을 막기 위한 용도입니다.
<code>handleSend</code> 동안 저장한 timeout ID에 대해 <a href="https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout" target="_blank" rel="noopener noreferrer"><code>clearTimeout</code></a>을 부르면서 작동합니다.
하지만, &quot;취소하기&quot;가 클릭된 후에도 &quot;보냈다!&quot; 메시지는 여전히 나타납니다. 작동하지 않는 이유를 찾아내서 고치세요.</p><iframe src="https://codesandbox.io/s/470l0z?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h3 class="anchor anchorWithStickyNavbar_LWe7" id="힌트">힌트<a class="hash-link" href="#힌트" title="제목으로 바로 가기">​</a></h3><p><code>let timeoutID</code>와 같은 일반적인 변수들은 리렌더링 사이에 &quot;살아남지&quot; 못합니다. 매 렌더링마다 컴포넌트를 밑바닥부터 다시 실행시키면서 컴포넌트의 변수들을 초기화 시키기 때문입니다.
timeout ID를 다른 어딘가에 저장해 두어야 하지 않을까요?</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="정답">정답<a class="hash-link" href="#정답" title="제목으로 바로 가기">​</a></h3><p>컴포넌트가 리렌더링 할 때마다 모든 지역 변수들은 완전히 초기화되어집니다.
<code>timeoutID</code>와 같은 지역 변수 속 timeout ID를 지키지 못했던 이유이며 미래에 또다른 이벤트 핸들러가 timeout ID를 &quot;보기&quot;를 기대한 이유입니다.
대신에, React가 렌더 사이에 값을 저장해두는 ref에 timeout ID를 저장하세요.</p><iframe src="https://codesandbox.io/s/3u5ioz?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-컴포넌트가-리렌더링에-실패하는-것을-수정하세요">2. 컴포넌트가 리렌더링에 실패하는 것을 수정하세요<a class="hash-link" href="#2-컴포넌트가-리렌더링에-실패하는-것을-수정하세요" title="제목으로 바로 가기">​</a></h2><p>이 버튼은 &quot;켜기&quot;와 &quot;끄기&quot;를 보여주는 토글입니다. 하지만, 이 버튼은 항상 &quot;끄기&quot;만을 보여줍니다.
이 코드에 무슨 문제가 있나요? 고쳐보세요.</p><iframe src="https://codesandbox.io/s/5mdcs0?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h3 class="anchor anchorWithStickyNavbar_LWe7" id="정답-1">정답<a class="hash-link" href="#정답-1" title="제목으로 바로 가기">​</a></h3><p>이 예시에서, ref의 현재 값은 렌더링 결과물을 계산하는데 사용되었습니다(<code>{isOnRef.current ? &#x27;On&#x27; : &#x27;Off&#x27;}</code>).
이 정보가 ref에 있어서 안된다는 신호이며 정보는 상태에 넣어져야 합니다.
이를 고치기 위해서 ref를 제거하고 대신에 상태를 사용하세요.</p><iframe src="https://codesandbox.io/s/crvwdb?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-디바운싱-고치기">3. 디바운싱 고치기<a class="hash-link" href="#3-디바운싱-고치기" title="제목으로 바로 가기">​</a></h2><p>이 예시에서, 모든 버튼 클릭 핸들러들은 <a href="https://redd.one/blog/debounce-vs-throttle" target="_blank" rel="noopener noreferrer">&quot;디바운싱&quot;</a>됩니다.
디바운싱이 무엇인지 알기 위해, 버튼 중 하나를 눌러보세요.
1초 후 메시지가 어떻게 나타나는지 보세요.
메시지를 기다리는 동안 버튼을 누르면, 타이머가 초기화됩니다.
그래서 만약 여러분이 빠르게 여러번 같은 버튼을 누르면 메시지는 클릭을 멈춘 뒤 일초 <em>후</em>에 나타납니다.
디바운싱은 여러분이 사용자가 &quot;행동하는 것을 멈출&quot; 때까지 행동에 대한 액션을 지연시키는 것입니다.</p><p>이 예시는 동작하지만 의도된 대로 잘 동작하지는 않습니다. 버튼들은 독립적이지 않습니다.
문제를 보면, 버튼 중 하나를 클릭하고 즉시 또다른 버튼을 클릭하세요.
약간의 지연 후 두 버튼 모두의 메시지를 보기를 기대했을 것입니다.
하지만 마지막 버튼의 메시지만 나타납니다. 첫번째 버튼의 메시지는 나오지 않습니다.</p><p>왜 버튼이 서로 방해할까요? 찾아서 문제를 고쳐보세요.</p><iframe src="https://codesandbox.io/s/xjm60d?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h3 class="anchor anchorWithStickyNavbar_LWe7" id="힌트-1">힌트<a class="hash-link" href="#힌트-1" title="제목으로 바로 가기">​</a></h3><p>마지막 timeout ID는 모든 <code>DebouncedButton</code> 컴포넌트들 사이에 공유됩니다.
이것이 버튼을 클릭하면 또다른 버튼의 timeout을 초기화시키는 이유입니다.
각각의 버튼에 대한 timeout ID를 분리해서 저장할 수 있나요?</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="정답-2">정답<a class="hash-link" href="#정답-2" title="제목으로 바로 가기">​</a></h3><p><code>timeoutID</code>와 같은 변수가 모든 컴포넌트 사이에 공유되고 있습니다.
이것이 두번째 버튼을 클릭하면 첫번째 버튼의 timeout을 초기화시키는 이유입니다.
이를 고치기 위해, timeout을 ref에 저장할 수 있습니다.
각각의 버튼은 각자의 ref를 가지고 있음으로서 그 버튼들은 서로 충돌하지 않습니다.
두 버튼을 얼마나 빨리 클릭하든 두 메시지들은 모두 보여질 것입니다.</p><iframe src="https://codesandbox.io/s/14lyv8?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-최신-상태를-읽기">4. 최신 상태를 읽기<a class="hash-link" href="#4-최신-상태를-읽기" title="제목으로 바로 가기">​</a></h2><p>이 예시에서 &quot;보내기&quot; 버튼을 누른 후 메시지가 보여지기 전 약간의 지연이 있습니다.
&quot;hello&quot;를 입력하고 보내기 버튼을 누른 후 빠르게 입력을 다시 수정합니다.
여러분의 수정에도 불구하고, 경고창은 &quot;hello&quot;(버튼이 클릭된 <a href="https://beta.reactjs.org/learn/state-as-a-snapshot#state-over-time" target="_blank" rel="noopener noreferrer">때</a>의 상태값)를 보여줄 것입니다. </p><p>보통, 이 행동은 앱에서 여러분이 원하는 행위입니다.
하지만, <em>가장 최신</em> 상태를 읽는 비동기적인 코드를 원하는 경우들이 가끔 있을지도 모릅니다.
클릭 했을 때의 문자가 아닌 <em>현재</em> 입력 문구를 경고창에 보여주는 방법을 생각할 수 있나요?</p><iframe src="https://codesandbox.io/s/jsmoh6?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><h3 class="anchor anchorWithStickyNavbar_LWe7" id="정답-3">정답<a class="hash-link" href="#정답-3" title="제목으로 바로 가기">​</a></h3><p>상태는 <a href="https://beta.reactjs.org/learn/state-as-a-snapshot" target="_blank" rel="noopener noreferrer">스냅샷</a>과 같이 작동하므로 timeout과 같이 비동기적인 작동으로 최근 상태값을 읽을 수 없습니다.
하지만, 가장 최신의 입력 문구를 ref에 저장할 수 있습니다.
ref는 수정 가능하므로 언제든 <code>current</code> 속성을 읽을 수 있습니다.
이 예시에서 최신 문구가 렌더링동안 사용되기 때문에, 상태변수(렌더링을 위해)와 ref(timeout 동안 문구를 읽기 위해) 둘 다 필요합니다.
여러분은 수동으로 최신 ref 값을 업데이트할 필요가 있습니다.</p><iframe src="https://codesandbox.io/s/6gk3ld?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/line-next-level/React-Docs-KOR/tree/main/docs/learn/Escape Hatches/referencing-values-with-refs.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="문서 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/React-Docs-KOR/docs/learn/Escape Hatches/escape-hatches"><div class="pagination-nav__sublabel">이전</div><div class="pagination-nav__label">탈출구 (Advanced)</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/React-Docs-KOR/docs/learn/Escape Hatches/manipulating-the-dom-with-refs"><div class="pagination-nav__sublabel">다음</div><div class="pagination-nav__label">Ref를 사용해 돔 조작하기</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#컴포넌트에-ref를-추가하기" class="table-of-contents__link toc-highlight">컴포넌트에 ref를 추가하기</a></li><li><a href="#예시-스톱워치-만들기" class="table-of-contents__link toc-highlight">예시: 스톱워치 만들기</a></li><li><a href="#ref와-상태-사이의-차이점들" class="table-of-contents__link toc-highlight">ref와 상태 사이의 차이점들</a></li><li><a href="#ref를-사용하는-경우" class="table-of-contents__link toc-highlight">ref를 사용하는 경우</a></li><li><a href="#ref를-사용한-좋은-예시들" class="table-of-contents__link toc-highlight">ref를 사용한 좋은 예시들</a></li><li><a href="#ref와-dom" class="table-of-contents__link toc-highlight">Ref와 DOM</a></li><li><a href="#되짚어보기" class="table-of-contents__link toc-highlight">되짚어보기</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></footer></div>
<script src="/React-Docs-KOR/assets/js/runtime~main.16dcfed8.js"></script>
<script src="/React-Docs-KOR/assets/js/main.ae80d2f5.js"></script>
</body>
</html>
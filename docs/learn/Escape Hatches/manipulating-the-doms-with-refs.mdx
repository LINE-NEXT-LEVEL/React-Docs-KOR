import {Code} from "../../../src/components/Code";React는 여러분의 컴포넌트가 자주 수정될 필요가 없도록 렌더링 결과물에 알맞게 자동으로 [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)을 업데이트합니다.
하지만 가끔은 React에 의해 관리되고 있는 DOM에 직접 접근해야 할 필요가 있습니다.
노드를 focus 한다거나, 그 노드로 스크롤을 해야 한다거나, 사이즈와 위치를 알아야 할 때가 적절한 예시입니다.
React에 그런 작업을 위한 빌트인 도구가 없기 때문에, _ref_를 통해 DOM 노드에 접근해야 합니다.

:::info 여러분이 배울 것
- React가 관리하는 DOM 노드에 `ref` 속성을 통해 접근하는 방법
- 어떻게 JSX `ref` 속성이 `useRef` hook과 관계를 맺는지.
- 다른 컴포넌트의 DOM 노드에 접근하는 방법
- React가 관리하는 DOM 노드를 직접 수정해도 안전한 경우
:::

## 노드에 대한 참조(ref)를 가져오기

React가 관리하는 DOM 노드에 접근하기 위해서는 `useRef` hook을 import 해야합니다.

```js
import { useRef } from 'react';
```

그리고, `useRef` hook을 컴포넌트 내에서 호출합니다.

```js
const myRef = useRef(null);
```

마지막으로 이를 DOM 노드의 `ref` 속성에 넘겨줍니다.

```js
<div ref={myRef}>
```

`useRef` hook은 `current`라는 하나의 속성을 갖고 있는 객체를 반환합니다.
처음에 `myRef.current`는 `null`입니다. React가 이 `<div>`에 대한 DOM 노드를 만들고 난 뒤, React는 이 노드에 대한 참조 객체를
`myRef.current`에 집어넣습니다. 이제 이 노드를 [이벤트 핸들러](https://beta.reactjs.org/learn/responding-to-events)에서 접근할 수 있고,
내장 [브라우저 API](https://developer.mozilla.org/docs/Web/API/Element)를 사용할 수도 있습니다.

```js
// 브라우저 API를 사용할 수 있습니다. 예를 들자면 아래와 같습니다.
myRef.current.scrollIntoView();
```

### 예시 : 텍스트 input을 focus 하기
이 예시에서, 버튼을 클릭하면 input이 focus 됩니다.

<Code src="https://codesandbox.io/embed/sweet-banzai-k2uec3?fontsize=14&hidenavigation=1&theme=dark" />

이를 구현하기 위해서는
1. `useRef` hook을 통해 `inputRef`를 선언합니다.
2. 이를 `<input ref={inputRef}>`에 넘깁니다. 이는 React에게 *이 `<input>`의 DOM 노드를 `inputRef.current`에 넣으라는 말과 같습니다.*
3. `handleClick` 함수 안에서 `inputRef.current`에 있는 DOM 노드의 참조를 읽고 `inputRef.current.focus()`를 통해 `[focus()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus)` 함수를 호출합니다.
4. `handleClick` 이벤트 핸들러를 `<button>`의 `onClick` 속성에 넘겨줍니다.

DOM 조작이 ref를 이용한 가장 흔한 경우이긴 하지만, `useRef` hook은 React 외부에서 타이머의 ID같은 다른 데이터를 저장하기 위해 쓰일 수도 있습니다.
State와 유사하지만 ref는 렌더링 중간에도 남아있습니다. Ref는 set 되어도 리렌더링을 유도하지 않는 state 변수들과 같다고 볼 수 있습니다.
Ref에 대한 내용을 더 알고 싶다면 [ref의 참조 변수](https://beta.reactjs.org/learn/referencing-values-with-refs)를 읽어보세요.

### 예시 : 요소로 스크롤 하기

컴포넌트 하나에 한 개 이상의 ref를 선언할 수 있습니다. 아래 예시에 세 이미지를 가진 캐러셀이 있습니다.
각 버튼은 브라우저의 `[scrollIntoView()](https://codesandbox.io/embed/priceless-lake-tzej7b?fontsize=14&hidenavigation=1&theme=dark)` 메소드를 불러 이에 상응하는 DOM 노드가 중간으로 오도록 합니다.

<Code src="https://codesandbox.io/embed/priceless-lake-tzej7b?fontsize=14&hidenavigation=1&theme=dark" />

:::note DEEP DIVE
위 예시에서, 이미 정의된 ref가 몇개 있습니다. 하지만, 가끔 배열의 각 아이템 갯수만큼 ref가 필요할 수도 있습니다.
그리고 얼마나 필요한지 여러분은 모르는 상황이죠. 아래와 같은 코드는 *동작하지 않을 겁니다.*

```jsx
<ul>
  {items.map((item) => {
    // 동작하지 않음!
    const ref = useRef(null);
    return <li ref={ref} />;
  })}
</ul>
```

이는 *hook이 항상 컴포넌트의 최상단에서 호출되어야 하기 때문입니다.* `useRef`는 루프나, 조건문이나, `map()` 내부에서 호출될 수 없습니다.

한가지 가능한 방법은 부모 요소에 하나의 ref를 두고, `[querySelectorAll](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll)`과 같은 메소드를 이용해 각각의 자식 노드들을 "찾는"것입니다.
하지만 이 방법은 안정성이 떨어지고 DOM 구조가 바뀔 경우 동작하지 않을 수 있습니다.

다른 방법은 *함수에 `ref` 속성을 넘기는 것*입니다. 이는 [`ref` 콜백](https://beta.reactjs.org/reference/react-dom/components/common#ref-callback)이라고 불리는 이 방법은 DOM 노드에 ref가 세팅되는 시점에 React로 하여금 콜백을 호출하도록 합니다.
그리고 초기화하는 시점에는 `null`이 됩니다. 이 방법은 배열이나 [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)을 사용하면서 index와 같은 ID를 통해 어떤 ref에도 접근할 수 있도록 합니다.

이 예시는 어떻게 이 접근법이 긴 배열 내부의 임의의 노드에 스크롤할 수 있는지를 보여줍니다.

<Code src="https://codesandbox.io/embed/flamboyant-heisenberg-zt4gd8?fontsize=14&hidenavigation=1&theme=dark" />

이 예시에서 `itemsRef`는 어떤 단일 DOM 노드도 들고 있지 않습니다.
대신 이는 아이템 ID를 DOM 노드로 매핑하는 [Map](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map)을 들고 있습니다.([ref는 어떤 값이든 저장할 수 있습니다.](https://beta.reactjs.org/learn/referencing-values-with-refs))
모든 배열 아이템의 [`ref` 콜백](https://beta.reactjs.org/reference/react-dom/components/common#ref-callback)은 Map을 업데이트 하는데 주의를 기울입니다.

```jsx
<li
  key={cat.id}
  ref={node => {
    const map = getMap();
    if (node) {
      // Map에 추가
      map.set(cat.id, node);
    } else {
      // Map에서 삭제
      map.delete(cat.id);
    }
  }}
>
```
이 방법은 나중에 Map에서 각각의 DOM 노드를 읽도록 해줍니다.
:::

## 다른 컴포넌트의 DOM 노드 접근하기

`<input>`과 같은 브라우저 요소를 출력하는 내장 구성 요소에 ref를 넣으면 React는 해당 ref의 `current` 속성을 해당 DOM 노드(브라우저의 실제 `<input />`같은)로 설정합니다.

하지만, ref를 `<MyInput />`과 같이 *직접 만든* 컴포넌트에 넘겨준다면 기본값은 `null`이 될 것입니다.
아래는 이를 보여주는 예시이빈다. 버튼을 클릭해도 input이 focus되지 *않는*다는 점에 유의하세요.

<Code src="https://codesandbox.io/embed/long-moon-jo1l20?fontsize=14&hidenavigation=1&theme=dark" />

여러분이 이 문제를 놓치지 않도록 하기 위해 React는 콘솔에 에러를 출력하기도 합니다.

:::danger
// console
Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?
:::

이 문제는 기본적으로 React에서 컴포넌트가 다른 컴포넌트 요소의 DOM 노드에 접근할 수 없기 때문에 발생합니다.
심지어 그 자식 컴포넌트에도 말입니다! 이건 의도된 것입니다. ref는 조심스럽게 사용해야 하는 탈출구와 같습니다.
다른 컴포넌트의 DOM 노드를 수동으로 조작하면 코드가 훨씬 취약해질 수 있습니다.

대신 DOM 노드를 _노출_하려는 컴포넌트가 해당 동작을 *선택*해야 합니다.
컴포넌트는 그 자식들 중 하나에게 ref를 "포워딩"할지를 선택할 수 있습니다. 아래는 `MyInput`이 `forwardRef` API를 사용하는 예시입니다.

```jsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

이 방법이 동작하는 방식은 아래와 같습니다.

1. `MyInput ref={inputRef} />`는 React에게 해당 DOM 노드를 `inputRef.current`에 넣으라고 지시합니다. 하지만, 이를 선택하는 것은 `MyInput`에게 달려 있습니다. 기본적으로는 그렇지 않습니다.
2. `MyInput`컴포넌트는 `fowradRef`를 이용해 선언되었습니다. *이를 통해 `inputRef`를 `props` 뒤의 두번째 인자인 `ref`를 통해 받을 것이라 선택합니다.*
3. `MyInput`은 `ref`를 `<input>`의 내부에 전달합니다.

이제 버튼을 클릭하면 input이 focus됩니다.

<Code src="https://codesandbox.io/embed/eager-waterfall-yudn35?fontsize=14&hidenavigation=1&theme=dark" />

디자인 시스템에서 ref를 DOM 노드에 포워딩 하는 것은 button, input과 같은 저수준 컴포넌트에 적용할 수 있는 흔한 패턴입니다.
반면에 form, list, page와 같은 고수준 컴포넌트에서는 예기치 못한 DOM 구조에 대한 의존성이 생기는 것을 막기 위해 DOM 노드를 잘 노출하지 않습니다.
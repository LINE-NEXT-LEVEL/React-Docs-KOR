<!doctype html>
<html lang="ko" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-learn/Managing State/choosing-the-state-structure">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">상태 구조를 선택하기 | React Docs KOR</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://line-next-level.github.io/React-Docs-KOR/docs/learn/Managing State/choosing-the-state-structure"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="상태 구조를 선택하기 | React Docs KOR"><meta data-rh="true" name="description" content="상태를 잘 구조화하는 것은 기쁘게 수정하고 디버그하는 컴포넌트와 지속적인 버그의 원인인 컴포넌트 사이의 차이를 만들어 냅니다."><meta data-rh="true" property="og:description" content="상태를 잘 구조화하는 것은 기쁘게 수정하고 디버그하는 컴포넌트와 지속적인 버그의 원인인 컴포넌트 사이의 차이를 만들어 냅니다."><link data-rh="true" rel="icon" href="/React-Docs-KOR/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://line-next-level.github.io/React-Docs-KOR/docs/learn/Managing State/choosing-the-state-structure"><link data-rh="true" rel="alternate" href="https://line-next-level.github.io/React-Docs-KOR/docs/learn/Managing State/choosing-the-state-structure" hreflang="ko"><link data-rh="true" rel="alternate" href="https://line-next-level.github.io/React-Docs-KOR/docs/learn/Managing State/choosing-the-state-structure" hreflang="x-default"><link rel="stylesheet" href="/React-Docs-KOR/assets/css/styles.2d3a33e4.css">
<link rel="preload" href="/React-Docs-KOR/assets/js/runtime~main.16dcfed8.js" as="script">
<link rel="preload" href="/React-Docs-KOR/assets/js/main.ae80d2f5.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="본문으로 건너뛰기"><a href="#" class="skipToContent_fXgn">본문으로 건너뛰기</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/React-Docs-KOR/"><div class="navbar__logo"><img src="/React-Docs-KOR/img/logo.svg" alt="React Docs Beta KOR" class="themedImage_ToTc themedImage--light_HNdA"><img src="/React-Docs-KOR/img/logo.svg" alt="React Docs Beta KOR" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">React Docs Beta KOR</b></a><a class="navbar__item navbar__link" href="/React-Docs-KOR/docs/learn/installation/add-react-to-website">learn</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="맨 위로 스크롤하기" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/React-Docs-KOR/docs/learn/Quick Start/thinking-in-react">GET STARTED</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/React-Docs-KOR/docs/learn/Describing the UI/describing-the-ui">LEARN REACT</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/React-Docs-KOR/docs/learn/Describing the UI/describing-the-ui">Describing the UI</a><button aria-label="접을 수 있는 사이드바 분류 &#x27;Describing the UI&#x27; 접기(펼치기)" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/React-Docs-KOR/docs/learn/Adding Interactivity/adding-interactivity">Adding Interactivity</a><button aria-label="접을 수 있는 사이드바 분류 &#x27;Adding Interactivity&#x27; 접기(펼치기)" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/React-Docs-KOR/docs/learn/Managing State/managing-state">Managing State</a><button aria-label="접을 수 있는 사이드바 분류 &#x27;Managing State&#x27; 접기(펼치기)" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Managing State/reacting-to-input-with-state">상태를 통해 입력값에 반응하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/React-Docs-KOR/docs/learn/Managing State/choosing-the-state-structure">상태 구조를 선택하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Managing State/sharing-state-between-components">컴포넌트 간 상태 공유</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Managing State/extracting-state-logic-into-a-reducer">상태 로직을 Reducer로 추출하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Managing State/passing-data-deeply-with-context">Context를 이용해 데이터를 깊게 넘기기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/React-Docs-KOR/docs/learn/Managing State/scaling-up-with-reducer-and-context">Reducer와 Context를 통해 확장하기</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/React-Docs-KOR/docs/learn/Escape Hatches/escape-hatches">Escape Hatches</a><button aria-label="접을 수 있는 사이드바 분류 &#x27;Escape Hatches&#x27; 접기(펼치기)" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="홈" class="breadcrumbs__link" href="/React-Docs-KOR/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">LEARN REACT</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/React-Docs-KOR/docs/learn/Managing State/managing-state"><span itemprop="name">Managing State</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">상태 구조를 선택하기</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">이 페이지에서</button></div><div class="theme-doc-markdown markdown"><h1>상태 구조를 선택하기</h1><p>상태를 잘 구조화하는 것은 기쁘게 수정하고 디버그하는 컴포넌트와 지속적인 버그의 원인인 컴포넌트 사이의 차이를 만들어 냅니다.
상태를 구조화할 때 생각해야 하는 몇 가지 팁들이 있습니다.</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>You will Learn</div><div class="admonitionContent_S0QG"><ul><li>단일 또는 다수의 상태 변수들을 사용하는 시기</li><li>상태를 구성할 때 피해야 하는 것</li><li>상태 구조로 일반적인 문제들을 고쳐내는 방법</li></ul></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="상태-구조화의-원칙">상태 구조화의 원칙<a class="hash-link" href="#상태-구조화의-원칙" title="제목으로 바로 가기">​</a></h2><p>여러 상태를 가지고 있는 컴포넌트를 작성할 때, 몇 개의 상태 변수들을 사용하고 각 상태 변수의 데이터는 어떤 형태를 띄어야 하는지에 대해서 선택을 해야 합니다.
차선의 상태 구조를 이용해 올바르게 작동하는 프로그램을 작성할 수 있지만, 더 나은 선택들로 여러분을 이끌어주는 몇 가지 원칙들이 있습니다:</p><ol><li><strong>관련된 상태들을 모읍니다.</strong> 두 개 또는 그 이상의 상태 변수들을 항상 동시에 업데이트한다면, 하나의 상태 변수로 그들을 묶는 걸 고려해 봅니다.</li><li><strong>상태 내부의 모순을 피합니다.</strong> 상태의 일부분들이 서로 모순되고 &quot;반대&quot;되는 구조일 때, 실수의 여지가 남겨집니다. 이 방식을 피하세요.</li><li><strong>불필요한 상태를 피합니다.</strong> 컴포넌트의 prop 또는 렌더링 동안 존재하는 상태 변수에게서 정보를 가져올 수 있다면, 그 정보를 가지고 있는 컴포넌트의 상태를 만들어서는 안됩니다.</li><li><strong>상태 내부의 중복을 피합니다.</strong> 여러 개의 상태 변수들이 같은 정보를 갖고 있거나 내부의 객체에 같은 정보를 갖고 있을 때, 모든 정보의 동기화를 맞추기 어렵습니다.
할 수 있는 한 중복을 줄이세요.</li><li><strong>깊이 중첩된 상태를 피합니다.</strong> 깊게 계층화된 상태는 업데이트하기 편하지 않습니다. 가능하면, 평평하게 상태를 구조화하세요.</li></ol><p>이 원칙들의 목표는 <em>실수 없이 상태 업데이트를 쉽게 만드는 것</em> 입니다.
상태의 불필요하고 중복되는 데이터를 제거하는 것은 모든 상태들이 동기화되었다는 것을 확신하게 도와줍니다.
데이터베이스 기술자가 버그를 줄이기 위해 <a href="https://learn.microsoft.com/en-us/office/troubleshoot/access/database-normalization-description" target="_blank" rel="noopener noreferrer">데이터베이스 구조를 &quot;정규화&quot;</a>하는 방식과 비슷합니다.
알버트 아인슈타인의 말을 인용하자면, <strong>&quot;상태를 가능한 단순하게 만드세요, 단 너무 단순하게는 말고</strong></p><p>이 원칙들이 실제로 어떻게 적용되는지 봅시다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="관련된-상태들을-모으기">관련된 상태들을 모으기<a class="hash-link" href="#관련된-상태들을-모으기" title="제목으로 바로 가기">​</a></h2><p>하나의 상태 변수를 사용할지 여러 개의 상태 변수를 사용할지 확신이 들지 않는 때가 종종 있습니다.</p><p>아래와 같이 할 건가요?</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">x</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> setX</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">y</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> setY</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>아니면 아래와 같이?</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">position</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> setPosition</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token literal-property property" style="color:#36acaa">x</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token literal-property property" style="color:#36acaa">y</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>기술적으로 어떤 접근법을 사용해도 됩니다. <strong>두 상태 변수들이 항상 함께 변경된다면, 하나의 상태 변수로 상태들을 통합하는 것이 좋은 생각으로 보입니다.</strong>
그러면 항상 상태들을 동기화하는 것을 놓치지 않을 것입니다. 커서를 옮기는 것이 빨간 점의 좌표 모두를 업데이트하는 아래 예시처럼 말입니다.</p><iframe src="https://codesandbox.io/s/13x7mv?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>객체 또는 배열에 데이터를 모으는 또다른 경우는 얼마나 많은 상태들이 필요한지 잘 모를 때입니다.
예를 들어, 사용자가 맞춤 필드를 사용자가 추가할 수 있는 폼이 있을 때 도움이 됩니다.</p><div class="theme-admonition theme-admonition-danger alert alert--danger admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>경고</div><div class="admonitionContent_S0QG"><p>만약 당신의 상태 변수가 객체라면 다른 필드를 명시적으로 복사하는 것 없이 객체 안의 하나의 필드만 업데이트할 수는 없습니다.
예를 들어, 위의 예시에서 <code>setPosition({ x: 100 })</code>을 할 수 없습니다. 그 이유는 <code>y</code> 요소를 가지고 있지 않기 때문입니다!
대신에, <code>x</code> 하나만을 업데이트하고 싶다면, <code>setPosition({ ...position, x: 100 })</code>으로 실행하거나 두개의 상태 변수들로 나누고 <code>setX(100)</code>을 실행합니다.</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="상태-내부의-모순을-피하기">상태 내부의 모순을 피하기<a class="hash-link" href="#상태-내부의-모순을-피하기" title="제목으로 바로 가기">​</a></h2><p>여기 <code>isSending</code>과 <code>isSent</code> 상태 변수들로 이루어진 호텔 피드백 폼이 있습니다.</p><iframe src="https://codesandbox.io/s/pkwdmp?file=/App.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>이 코드는 작동하지만,
<code>setIsSent</code>와 <code>setIsSending</code>을 함꼐 부르는 것을 잊었다면, <code>isSending</code>과 <code>isSent</code>가 동시에 <code>true</code>인 상황에 놓여져 있을지도 모릅니다.
컴포넌트가 더 복잡할수록, 무슨 일이 일어날지 이해하기 쉽지 않습니다.</p><p><strong><code>isSending</code>과 <code>isSent</code>가 동시에 <code>true</code>가 되면 절대 안되기 때문에, 하나의 <code>status</code> 상태 변수로 상태들을 교체하는 게 더 좋습니다. <code>status</code> 상태 변수는 <code>typing</code>(기본값), <code>sending</code>, <code>sent</code> ~세가지~ 상태들 중 하나를 가질 수 있습니다.</strong></p><iframe src="https://codesandbox.io/s/ue8v0i?file=/App.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>가독성을 위해 몇 개의 상수들을 선언할 수 있습니다:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> isSending </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> status </span><span class="token operator" style="color:#393A34">===</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;sending&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> isSent </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> status </span><span class="token operator" style="color:#393A34">===</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;sent&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>하지만 그 상수들은 상태 변수가 아니기에 상수들이 동기화에 벗어나는 것을 걱정할 필요는 없습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="불필요한-상태를-피하기">불필요한 상태를 피하기<a class="hash-link" href="#불필요한-상태를-피하기" title="제목으로 바로 가기">​</a></h2><p>렌더링 동안 컴포넌트의 prop 또는 컴포넌트에 존재하는 상태 변수로부터 정보를 계산할 수 있다면, 다른 컴포넌트의 상태로 그 정보를 넣어서는 <strong>안됩니다</strong>.</p><p>예를 들어, 아래 폼을 보세요. 작동하지만 폼 안에서 불필요한 상태를 찾을 수 있습니까?</p><iframe src="https://codesandbox.io/s/3w14pb?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>위의 폼은 <code>firstName</code>, <code>lastName</code>, <code>fullName</code> 세 가지 상태 변수들을 가지고 있습니다.
하지만, <code>fullName</code>은 불필요합니다.
<strong>렌더링 동안 <code>firstName</code>과 <code>lastName</code>으로 <code>fullName</code>을 항상 만들 수 있기에, <code>fullName</code>을 상태에서 제거하세요.</strong></p><p>아래 코드가 올바른 방식을 적용한 방법입니다:</p><iframe src="https://codesandbox.io/s/b8ive6?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p><code>fullName</code>은 상태 변수가 <em>아닙니다.</em>
대신에, 렌더링 동안 계산되어집니다:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> fullName </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> firstName </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27; &#x27;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> lastName</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>결과적으로, change handler는 <code>fullName</code>을 업데이트하기 위한 특정한 무언가를 할 필요가 없습니다.
<code>setFirstName</code> 또는 <code>setLastName</code>을 부를 때, 리렌더링을 유발하고, 그리고 나서 <code>fullName</code>은 새로운 데이터로 계산되어질 것입니다.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Deep Dive</div><div class="admonitionContent_S0QG"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="상태에-prop을-반영하지-않기">상태에 prop을 반영하지 않기<a class="hash-link" href="#상태에-prop을-반영하지-않기" title="제목으로 바로 가기">​</a></h2><p>불필요한 상태의 흔한 예시는 아래 코드와 같습니다:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:#d73a49">Message</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter punctuation" style="color:#393A34">{</span><span class="token parameter"> messageColor </span><span class="token parameter punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">color</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> setColor</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">messageColor</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>color</code> 상태 변수는 <code>messageColor</code> prop으로 초기화되어집니다.
문제는 <strong>만약 나중에 부모컴포넌트가 <code>messageColor</code>로 다른 값을 건넨다면(예를 들어, <code>blue</code> 대신에 <code>red</code>) <code>color</code> 상태 변수는 업데이트되지 않을 것입니다!</strong>
상태는 첫번째 렌더링 동안만 초기화됩니다.</p><p>상태 변수에 prop을 &quot;반영&quot;하는 것이 혼란을 야기할 수 있는 이유입니다.
대신에 코드에 <code>messageColor</code> prop을 직접 사용합니다.
더 짧은 이름을 주기를 원한다면, 상수를 사용합니다:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:#d73a49">Message</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter punctuation" style="color:#393A34">{</span><span class="token parameter"> messageColor </span><span class="token parameter punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> color </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> messageColor</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>아래처럼 하면 부모 컴포넌트로부터 건네받은 prop과 상태가 동기화되지 않습니다.</p><p>상태에 prop을 &quot;반영&quot;하는 것은 특정 prop의 모든 업데이트를 무시하고 싶을 때 사용할 수 있습니다.
컨밴션에 따르면, 새로운 값이 무시될 것이라는 것을 나타내기 위해  <code>initial</code> 또는 <code>default</code>으로 시작되는 prop 이름을 사용합니다:</p><div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:#d73a49">Message</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter punctuation" style="color:#393A34">{</span><span class="token parameter"> initialColor </span><span class="token parameter punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// `color` 상태 변수는 `initialColor`의 *첫번째* 값을 가지고 있습니다.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">//  이후 `initialColor`의 변경은 무시됩니다.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">color</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> setColor</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">useState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">initialColor</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="상태-내부의-중복을-피하기">상태 내부의 중복을 피하기<a class="hash-link" href="#상태-내부의-중복을-피하기" title="제목으로 바로 가기">​</a></h2><p>아래 메뉴 목록 컴포넌트는 여러 개 중 하나의 여행용 과자를 선택하도록 합니다.</p><iframe src="https://codesandbox.io/s/3ll5lu?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>현재, <code>selectedItem</code> 상태 변수 속에 객체로 선택된 아이템을 저장하고 있습니다.
하지만, 이것은 좋지 않습니다: <strong><code>selectedItem</code>의 내용이 <code>items</code> 목록 내부의 아이템들 중 하나와 같은 객체이기 때문입니다.</strong>
이는 아이템에 대한 정보가 두 곳에서 중복된다는 것을 의미합니다.</p><p>왜 이것이 문제일까요? 각 아이템이 수정가능하도록 만들어봅시다:</p><iframe src="https://codesandbox.io/s/bnggym?file=/App.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>목록의 &quot;선택&quot;을 처음 누르고나서 아이템을 수정한다면, <strong>입력값이 업데이트되지만 아래에 있는 값은 해당 수정사항을 반영하지 못하는 것을 볼 수 있습니다.</strong>
이는 중복된 상태를 가지고 있어 <code>selectedItem</code>을 업데이트하는 것을 잊었기 때문입니다.</p><p><code>selectedItem</code>도 업데이트할 수 있지만, 더 쉬운 수정은 중복을 제거하는 것입니다.
이 예시에서는 <code>selectedItem</code> 객체(<code>items</code> 내부의 객체와 중복을 가짐) 대신에 상태에 <code>selectedId</code>를 가지고 그 ID로 아이템 목록인 <code>items</code>에서 <code>selectedItem</code>을 찾을 수 있습니다.</p><iframe src="https://codesandbox.io/s/5b25vk?file=/App.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>(다른 방법으로는 상태로 선택된 인덱스를 가질 수 있습니다.)</p><p>상태는 아래와 같이 중복되어서 사용되고 있었습니다:</p><ul><li><code>items = [{ id: 0, title: &#x27;pretzels&#x27;}, ...]</code></li><li><code>selectedItem = {id: 0, title: &#x27;pretzels&#x27;}</code></li></ul><p>수정 후에는 아래와 같이 변했습니다:</p><ul><li><code>items = [{ id: 0, title: &#x27;pretzels&#x27;}, ...]</code></li><li><code>selectedId = 0</code></li></ul><p>중복은 사라졌고, 필수적인 상태만 유지하고 있습니다!</p><p>이제 <em>선택된</em> 아이템을 수정한다면, 아래에 있는 값이 바로 업데이트될 것입니다.
<code>setItems</code>가 리렌더링을 유발하고 <code>items.find(...)</code>가 업데이트된 제목으로 아이템을 찾을 것입니다.
<em>선택된 ID</em>가 필수적이며 <em>선택된 아이템</em>을 상태로 가지고 있을 필요가 없습니다.
렌더링동안 나머지 부분들이 계산되어집니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="깊이-중첩된-상태를-피하기">깊이 중첩된 상태를 피하기<a class="hash-link" href="#깊이-중첩된-상태를-피하기" title="제목으로 바로 가기">​</a></h2><p>행성, 대륙 그리고 나라로 이루어진 여행 계획을 상상해봅니다.
아래 예시와 같이, 중첩된 객체와 배열을 사용해 상태를 구조화하려 시도할지도 모릅니다.</p><iframe src="https://codesandbox.io/s/1n8twj?file=%2Fplaces.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>이제 여러분이 이미 방문했던 장소를 지우는 버튼을 추가하기를 원한다고 가정해봅시다.
어떻게 이 요건을 만족시킬 건가요?
<a href="https://beta.reactjs.org/learn/updating-objects-in-state#updating-a-nested-object" target="_blank" rel="noopener noreferrer">중첩된 상태를 업데이트하는 것</a>은 변화된 부분에서부터 끝까지 객체의 복사본을 만들어야 합니다.
깊게 중첩된 곳을 제거하는 것은 그 곳의 전체 부모까지 모두 복사하는 것을 의미합니다.
그러한 코드는 매우 장황할 수 있습니다.</p><p><strong>만약 상태가 너무 중첩되서 쉽게 업데이트되지 않는다면, &quot;평평&quot;하게 상태를 만드는 것을 고려해봐야 합니다.</strong>
여기 중첩된 데이터를 재구조화하는 방법이 쓰여있습니다.
각각의 <code>place</code>가 자식 장소들을 배열로 가지고 있는 트리 구조 대신에, 각 장소가 <em>자식 장소 ID</em> 배열을 가지고 있을 수 있습니다.
그러면 각각의 장소 ID를 대응하는 장소로 짝지을 수 있습니다.</p><p>아래에 재구조화된 데이터는 데이터베이스 table처럼 보여질지도 모릅니다:</p><iframe src="https://codesandbox.io/s/cdkq4k?file=%2Fplaces.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p><strong>이제 상태는 &quot;평평&quot;하고(또는 &quot;정규화&quot;되었고) 중첩된 아이템들을 더 쉽게 업데이트할 수 있게 되었습니다.</strong></p><p>장소를 제거하기 위해서, 상태의 두 단계만을 업데이트할 필요가 있습니다:</p><ul><li>부모 장소의 업데이트된 버전은 <code>childIds</code> 배열에서 제거된 ID를 제외해야 합니다.</li><li>root &quot;table&quot; 객체의 업데이트된 버전은 부모 장소의 업데이트된 버전을 포함해야 합니다.</li></ul><p>아래에 올바른 방식의 예제가 있습니다:</p><iframe src="https://codesandbox.io/s/qf818i?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>원하는 만큼 상태를 중첩할 수 있지만, &quot;평평&quot;하게 상태를 만드는 것은 많은 문제들을 해결할 수 있습니다.
상태를 더 쉽게 업데이트하는 것이 가능하지만, 중첩된 객체의 다른 부분에서 중복을 피할 수 있게 도와줍니다.</p><p>:::Info Deep Dive</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="메모리-사용량-개선해보기">메모리 사용량 개선해보기<a class="hash-link" href="#메모리-사용량-개선해보기" title="제목으로 바로 가기">​</a></h2><p>이상적으로, 여러분은 메모리 사용성을 향상시키기 위해 &quot;table&quot; 객체에서 제거된 아이템(그리고 그 자식도!)을 삭제하고 싶어할 수 있습니다.
아래 버전에 반영되어 있습니다.
업데이트 로직을 보다 간결하게 만들기 위해 <a href="https://beta.reactjs.org/learn/updating-objects-in-state#write-concise-update-logic-with-immer" target="_blank" rel="noopener noreferrer">Immer를 사용</a>합니다.</p><iframe src="https://codesandbox.io/s/zim79i?file=/App.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>:::<p>가끔, 자식 컴포넌트로 중첩된 상태의 일부를 이동시킴으로서 상태 중첩을 줄일 수 있습니다.
이는 저장이 필요하지 않은 일시적인 UI 상태에서는 잘 동작합니다. 예를 들어, 아이템이 hover되었는지 아닌지가 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="되짚어보기">되짚어보기<a class="hash-link" href="#되짚어보기" title="제목으로 바로 가기">​</a></h2><ul><li>만약 두 상태 변수들이 항상 함께 업데이트된다면, 하나로 그들을 합치는 걸 고려합니다.</li><li>&quot;불가능한&quot; 상태들을 만드는 것을 피하기 위해 주의해서 상태 변수들을 선택합니다.</li><li>상태를 업데이트하는 데 실수를 줄이는 방식으로 상태를 구조화합니다.</li><li>불필요하고 중복적인 상태를 피합니다. 상태를 동기화할 필요가 없어집니다.</li><li>업데이트를 막기를 원하지 않는 경우를 제외하고 상태 <em>속에</em> prop을 넣지 않습니다.</li><li>선택과 같은 UI 패턴을 위해, 객체 그 자체를 상태로 쓰는 것 대신에 ID 또는 index를 상태로 사용합니다.</li><li>중첩된 상태가 깊게 복잡하다면, 상태를 평평하게 만드려 노력해야 합니다.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="도전-과제">도전 과제<a class="hash-link" href="#도전-과제" title="제목으로 바로 가기">​</a></h2><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>문제에 도전해보세요.</div><div class="admonitionContent_S0QG"><h3 class="anchor anchorWithStickyNavbar_LWe7" id="도전-1-업데이트하지-않는-컴포넌트를-고치기">도전 1: 업데이트하지 않는 컴포넌트를 고치기<a class="hash-link" href="#도전-1-업데이트하지-않는-컴포넌트를-고치기" title="제목으로 바로 가기">​</a></h3><p><strong>도전 1: 업데이트하지 않는 컴포넌트를 고치기</strong></p><p>이 <code>Clock</code> 컴포넌트는 <code>color</code>와 <code>time</code> 두개의 prop을 받습니다.
선택창에서 다른 색깔을 고를 때, <code>Clock</code> 컴포넌트는 부모 컴포넌트로부터 다른 <code>color</code> prop을 받습니다.
하지만, 모종의 이유로 표시되는 색깔은 업데이트되지 않습니다. 왜일까요? 문제를 고쳐보세요.</p><iframe src="https://codesandbox.io/s/wkpf1p?file=%2FClock.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><blockquote><p><strong>정답</strong></p></blockquote><blockquote><p>문제는 이 컴포넌트가 <code>color</code> prop의 초기값으로 초기화된 <code>color</code> 상태를 가지고 있는 것입니다.
하지만 <code>color</code> prop이 변경될 때, 상태 변수에 prop이 영향을 주지 않습니다!
그래서 동기화가 맞지 않았습니다. 이 문제를 해결하기 위해, 상태 변수를 모두 제거하고 <code>color</code> prop을 직접 사용하세요.</p></blockquote><iframe src="https://codesandbox.io/s/848koo?file=%2FClock.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><blockquote><p>또는 재분해 문법을 사용하세요:</p></blockquote><iframe src="https://codesandbox.io/s/6gieex?file=%2FClock.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe></div></div><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>문제에 도전해보세요.</div><div class="admonitionContent_S0QG"><h3 class="anchor anchorWithStickyNavbar_LWe7" id="도전-2-고장난-포장목록을-고치기">도전 2: 고장난 포장목록을 고치기<a class="hash-link" href="#도전-2-고장난-포장목록을-고치기" title="제목으로 바로 가기">​</a></h3><p><strong>도전 2: 고장난 포장목록을 고치기</strong></p><p>이 포장목록은 몇 개의 아이템들이 있고 몇 개의 아이템들이 포장되었는지 보여주는 footer를 가지고 있습니다.
처음에는 작동을 하는 것처럼 보이지만 버그가 있습니다.
예를 들어, 아이템을 포장된 것으로 체크하고나서 그것을 삭제하면, 개수가 정확하게 업데이트되지 않을 것입니다.
개수 계산이 항상 정확하게 맞도록 고치세요.</p><iframe src="https://codesandbox.io/s/xkuim8?file=/App.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><blockquote><p><strong>힌트</strong></p></blockquote><blockquote><p>이 예시에서 불필요한 상태가 있습니까?</p></blockquote><blockquote><p><strong>정답</strong></p></blockquote><blockquote><p><code>total</code>과 <code>packed</code> 개수를 정확하게 업데이트하는 각각의 이벤트 핸들러를 주의깊게 변경할 수 있지만, 근본적인 문제는 이 상태 변수들이 이미 존재한다는 것입니다.
이 상태 변수들은 불필요합니다. 그 이유는 항상 <code>items</code> 배열에서 아이템의 개수(포장 또는 전체)를 항상 계산할 수 있기 때문입니다.
버그를 고치기 위해 불필요한 상태를 제거하세요:</p></blockquote><iframe src="https://codesandbox.io/s/c1slci?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe> <blockquote><p>변화 직후 이벤트 핸들러가 어떻게 <code>setItems</code>를 부르는 것에만 집중하는지 주목하세요.
아이템 개수는 다음 렌더링 동안 <code>items</code>로부터 잘 계산되어지면서 항상 동기화됩니다.</p></blockquote></div></div><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>문제에 도전해보세요.</div><div class="admonitionContent_S0QG"><h3 class="anchor anchorWithStickyNavbar_LWe7" id="도전-3-사라지는-선택-영역을-수정하기">도전 3: 사라지는 선택 영역을 수정하기<a class="hash-link" href="#도전-3-사라지는-선택-영역을-수정하기" title="제목으로 바로 가기">​</a></h3><p><strong>도전 3: 사라지는 선택 영역을 수정하기</strong></p><p>상태에 <code>letters</code> 목록이 있습니다.
특정 편지에 마우스를 올리면, 하이라이트가됩니다.
가장 최근에 하이라이트된 편지가 <code>highlightedLetter</code> 상태변수에 저장됩니다.
특정 편지들을 &quot;star&quot;하거나 &quot;unstar&quot;함으로 <code>letters</code> 배열 상태를 업데이트할 수 있습니다.</p><p>아래 코드는 동작하지만 사소한 UI 문제가 있습니다.
&quot;Star&quot; 또는 &quot;Unstar&quot;를 눌렀을 때, 하이라이트는 잠시동안 사라집니다.
하지만, 키보드를 이용해 다른 편지로 옮기거나 마우스포인터를 옮기자마자 다시 나타납니다. 왜 이런 현상이 나타날까요?
하이라이팅이 버튼을 클릭한 이후 사라지지 않도록 고쳐보세요.</p><iframe src="https://codesandbox.io/s/8j33b9?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><blockquote><p><strong>정답</strong></p></blockquote><blockquote><p>문제는 <code>highlightedLetter</code> 안에 편지객체를 가지고 있기 때문입니다.
<code>letters</code> 배열에 같은 정보를 가지고 있습니다.
따라서 상태가 중복됩니다! 버튼클릭 이후 <code>letters</code> 배열을 업데이트할 때, <code>highlightedLetter</code>과는 다른 편지 객체를 새롭게 만듭니다.
<code>highlightedLetter === letter</code>이 <code>false</code>가 되는 이유이며 하이라이트가 사라지는 이유입니다.
마우스 포인터가 이동하고 <code>setHighlightedLetter</code>가 불리울 때 하이라이트가 다시 나타납니다.</p></blockquote><blockquote><p>문제를 해결하기 위해, 상태에서 중복을 제거합니다.
두 곳에서 편지 <em>그 자체</em>를 저장하는 것 대신에 <code>highlightedId</code>를 저장합니다.
<code>letter.id === highlightedId</code>를 이용해 각 편지의 <code>isHighlighted</code>를 체크할 수 있습니다. 결과적으로 <code>letter</code> 객체는 마지막 렌더링 이후 변화되었을지라도 잘 작동합니다.</p></blockquote><iframe src="https://codesandbox.io/s/6jck5y?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe></div></div><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>문제에 도전해보세요.</div><div class="admonitionContent_S0QG"><h3 class="anchor anchorWithStickyNavbar_LWe7" id="도전-4-다중-선택-구현하기">도전 4: 다중 선택 구현하기<a class="hash-link" href="#도전-4-다중-선택-구현하기" title="제목으로 바로 가기">​</a></h3><p><strong>도전 4: 다중 선택 구현하기</strong></p><p>이 예시에서, <code>Letter</code> 컴포넌트는 편지가 선택되었다는 것을 표시하는 <code>isSelected</code> prop과 <code>onToggle</code> 핸들러를 가지고 있습니다.
이 예시는 작동하지만 상태는 <code>selectedId</code>(<code>null</code> 또는 ID)만 저장하고 있어 한번에 오직 하나의 편지만 선택될 수 있습니다.</p><p>다중선택을 지원하기 위해 상태 구조를 변경해봅시다. (어떻게 구조화해야 할까요? 코드를 작성하기 전에 아래 내용을 생각해보세요.)
각각의 체크박스는 다른 체크박스들로부터 독립적이어야 합니다.
선택된 편지를 클릭하는 것은 편지의 선택을 해제합니다.
마지막으로, footer는 선택된 아이템 개수를 정확하게 보여주어야 합니다.</p><iframe src="https://codesandbox.io/s/bpfqi3?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><blockquote><p><strong>힌트</strong></p></blockquote><blockquote><p>하나의 선택된 ID 대신에, 선택된 ID 집합 또는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener noreferrer">배열</a>을 상태에 가질 수 있습니다.</p></blockquote><blockquote><p><strong>정답</strong></p></blockquote><blockquote><p>하나의 <code>selectedId</code> 대신에, 상태가 <code>selectedIds</code>배열을 가집니다.
예를 들어, 첫번째 그리고 마지막 편지를 선택했다면, 편지는 <code>[0, 2]</code>를 포함하고 있습니다.
아무것도 선택되지 않았을 때, 빈 <code>[]</code>배열이 될 것입니다:</p></blockquote><iframe src="https://codesandbox.io/s/xxrgl4?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><blockquote><p>배열을 사용하는 데 있어 한가지 사소한 단점은 각각의 아이템에 대해서 아이템이 선택되었는지를 체크하기 위해 <code>selectedIds.includes(letter.id)</code>를 불러야 한다는 것입니다.
만약 배열이 너무 크다면, 성능문제가 될 수 있습니다.
왜냐하면 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="noopener noreferrer"><code>includes()</code></a>를 이용해 배열을 탐색하는 것은 시간에 정비례하고 각각의 아이템에 이 검색을 하기 때문입니다.</p></blockquote><blockquote><p>이를 해결하기 위해, 더 빠른 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has" target="_blank" rel="noopener noreferrer"><code>has()</code></a>를 제공하는 집합(Set)으로 상태를 가지고 있을 수 있습니다.</p></blockquote><iframe src="https://codesandbox.io/s/8976uk?file=%2FApp.js&amp;utm_medium=sandpack" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sandpack-project" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><blockquote><p>각각의 아이템은 더 빠르게 <code>selectedIds.has(letter.id)</code>체크합니다.</p></blockquote><blockquote><p>상태 내부의 객체 또는 집합을 변경해서는 안되는 것을 주의하세요.
이 주의 때문에 <code>handleToggle</code>함수가 집합의 <em>복사본</em>을 만들고 복사본을 업데이트합니다.</p></blockquote></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/line-next-level/React-Docs-KOR/tree/main/docs/learn/Managing State/choosing-the-state-structure.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="문서 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/React-Docs-KOR/docs/learn/Managing State/reacting-to-input-with-state"><div class="pagination-nav__sublabel">이전</div><div class="pagination-nav__label">상태를 통해 입력값에 반응하기</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/React-Docs-KOR/docs/learn/Managing State/sharing-state-between-components"><div class="pagination-nav__sublabel">다음</div><div class="pagination-nav__label">컴포넌트 간 상태 공유</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#상태-구조화의-원칙" class="table-of-contents__link toc-highlight">상태 구조화의 원칙</a></li><li><a href="#관련된-상태들을-모으기" class="table-of-contents__link toc-highlight">관련된 상태들을 모으기</a></li><li><a href="#상태-내부의-모순을-피하기" class="table-of-contents__link toc-highlight">상태 내부의 모순을 피하기</a></li><li><a href="#불필요한-상태를-피하기" class="table-of-contents__link toc-highlight">불필요한 상태를 피하기</a></li><li><a href="#상태-내부의-중복을-피하기" class="table-of-contents__link toc-highlight">상태 내부의 중복을 피하기</a></li><li><a href="#깊이-중첩된-상태를-피하기" class="table-of-contents__link toc-highlight">깊이 중첩된 상태를 피하기</a></li><li><a href="#메모리-사용량-개선해보기" class="table-of-contents__link toc-highlight">메모리 사용량 개선해보기</a></li><li><a href="#되짚어보기" class="table-of-contents__link toc-highlight">되짚어보기</a></li><li><a href="#도전-과제" class="table-of-contents__link toc-highlight">도전 과제</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></footer></div>
<script src="/React-Docs-KOR/assets/js/runtime~main.16dcfed8.js"></script>
<script src="/React-Docs-KOR/assets/js/main.ae80d2f5.js"></script>
</body>
</html>